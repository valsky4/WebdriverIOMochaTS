"use strict";
/**
 * Runs TypeDoc
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildReferenceDocs = exports.runTypedoc = void 0;
const support_1 = require("@appium/support");
const glob_1 = __importDefault(require("glob"));
const lodash_1 = __importDefault(require("lodash"));
const node_path_1 = __importDefault(require("node:path"));
const typedoc_1 = require("typedoc");
const constants_1 = require("../constants");
const error_1 = require("../error");
const fs_1 = require("../fs");
const logger_1 = __importDefault(require("../logger"));
const util_1 = require("../util");
const log = logger_1.default.withTag('typedoc');
/**
 * Replaces TypeDoc's homebrew "glob" implementation with a real one
 *
 * This cannot be done via `require('typedoc')` or `import` due to the file being excluded
 * from the export map in its `package.json`.
 * @see https://github.com/TypeStrong/typedoc/issues/2151
 */
const monkeyPatchGlob = lodash_1.default.once((pkgRoot) => {
    const tdFs = require(node_path_1.default.join(pkgRoot, 'node_modules', 'typedoc', 'dist', 'lib', 'utils', 'fs.js'));
    tdFs.glob = glob_1.default.sync;
});
/**
 * Executes TypeDoc _in the current process_
 *
 * Monkeypatches TypeDoc's homebrew "glob" implementation because it is broken
 * @param pkgRoot - Package root path
 * @param opts - TypeDoc options
 */
async function runTypedoc(pkgRoot, opts) {
    monkeyPatchGlob(pkgRoot);
    log.debug('Monkeypatched TypeDoc');
    const args = (0, util_1.argify)(opts);
    log.debug('TypeDoc args:', args);
    const app = new typedoc_1.Application();
    app.options.addReader(new typedoc_1.TypeDocReader());
    app.options.addReader(new typedoc_1.ArgumentsReader(100, args));
    app.bootstrap();
    log.debug('Frozen options as computed by TypeDoc: %O', app.options.getRawValues());
    const out = app.options.getValue('out');
    const project = app.convert();
    if (project) {
        return await app.generateDocs(project, out);
    }
    throw new error_1.DocutilsError('TypeDoc found nothing to document. Is your package empty?');
}
exports.runTypedoc = runTypedoc;
/**
 * Mapping of whatever our log level is to whatever TypeDoc's should be.
 *
 * TypeDoc's "info" is too verbose for our needs, and it's our default, so
 * we map it to "warn".
 */
const TypeDocLogLevelMap = {
    debug: 'Verbose',
    info: 'Warn',
    warn: 'Warn',
    error: 'Error',
};
/**
 * Build reference documentation via TypeDoc
 * @param opts - Options
 */
async function buildReferenceDocs({ typedocJson: typeDocJsonPath, cwd = process.cwd(), tsconfigJson: tsconfig, logLevel = constants_1.DEFAULT_LOG_LEVEL, title, } = {}) {
    const stop = (0, util_1.stopwatch)('buildReferenceDocs');
    typeDocJsonPath = typeDocJsonPath
        ? node_path_1.default.resolve(cwd, typeDocJsonPath)
        : await (0, fs_1.findTypeDocJsonPath)(cwd);
    if (!typeDocJsonPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_TYPEDOC_JSON} from ${cwd}; run "${constants_1.NAME_BIN}" to create it`);
    }
    const pkgRoot = support_1.fs.findRoot(cwd);
    const relativePath = (0, util_1.relative)(cwd);
    const relativeTypeDocJsonPath = relativePath(typeDocJsonPath);
    log.debug(`Using ${relativeTypeDocJsonPath} as typedoc.json`);
    let typeDocJson;
    // we only need typedoc.json to make sure we have a custom "out" path.
    try {
        typeDocJson = (0, fs_1.readTypedocJson)(typeDocJsonPath);
        log.debug('Contents of %s: %O', relativeTypeDocJsonPath, typeDocJson);
    }
    catch (err) {
        log.error(err);
        throw new error_1.DocutilsError(`Could not read ${relativeTypeDocJsonPath}; run "${constants_1.NAME_BIN} init" to create it`);
    }
    // if for some reason "out" is not in typedoc.json, we want to use our default path.
    // otherwise, typedoc's default behavior is to write to the "docs" dir, which is the same dir that
    // we use (by default) as a source dir for the mkdocs site--which might contain files under vcs.
    let out;
    if (!typeDocJson.out) {
        out = node_path_1.default.relative(node_path_1.default.dirname(typeDocJsonPath), node_path_1.default.join(pkgRoot, constants_1.DEFAULT_REL_TYPEDOC_OUT_PATH));
        log.debug('Overriding "out" option with %s', out);
    }
    else {
        out = typeDocJson.out;
        log.debug(`Found "out" option in ${constants_1.NAME_TYPEDOC_JSON}: ${out}`);
    }
    const extraTypedocOpts = lodash_1.default.pickBy({ tsconfig, name: title, out, logLevel: TypeDocLogLevelMap[logLevel] }, Boolean);
    log.debug('Extra typedoc opts: %O', extraTypedocOpts);
    try {
        await runTypedoc(pkgRoot, extraTypedocOpts);
        log.success('Reference docs built at %s (%dms)', node_path_1.default.isAbsolute(out) ? relativePath(out) : out, stop());
    }
    catch (err) {
        log.error(err);
    }
}
exports.buildReferenceDocs = buildReferenceDocs;
//# sourceMappingURL=typedoc.js.map