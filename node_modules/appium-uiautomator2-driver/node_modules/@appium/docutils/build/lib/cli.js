#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const lodash_1 = __importDefault(require("lodash"));
const yargs_1 = __importDefault(require("yargs/yargs"));
const helpers_1 = require("yargs/helpers");
const init_1 = require("./init");
const logger_1 = __importDefault(require("./logger"));
const error_1 = require("./error");
const consola_1 = require("consola");
const util_1 = require("./util");
const build_1 = require("./build");
const validate_1 = require("./validate");
const NAME_GROUP_INIT_BEHAVIOR = 'Initialization Behavior:';
const NAME_GROUP_INIT_MKDOCS = 'MkDocs Config:';
const NAME_GROUP_BUILD_REFERENCE = 'Build API:';
const NAME_GROUP_INIT_PATHS = 'Paths:';
const NAME_GROUP_VALIDATE = 'Validation:';
const LogLevelName = {
    silent: consola_1.LogLevel.Silent,
    error: consola_1.LogLevel.Error,
    warn: consola_1.LogLevel.Warn,
    info: consola_1.LogLevel.Info,
    debug: consola_1.LogLevel.Debug,
};
async function main(argv = (0, helpers_1.hideBin)(process.argv)) {
    const done = (0, util_1.stopwatch)('main');
    const y = (0, yargs_1.default)(argv);
    return await y
        .scriptName('appium-docs')
        .command('build', 'Build docs', (yargs) => {
        return yargs.options({
            'mkdocs-path': {
                describe: 'Path to mkdocs.yml',
                normalize: true,
                type: 'string',
                nargs: 1,
                array: false,
            },
        });
    }, async () => { })
        .command('validate', 'Validate Environment', (yargs) => yargs.options({
        python: {
            default: true,
            description: 'Validate Python 3 environment',
            group: NAME_GROUP_VALIDATE,
            type: 'boolean',
        },
        'python-path': {
            defaultDescription: '(derived from shell)',
            description: 'Path to python 3 executable',
            group: NAME_GROUP_VALIDATE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        'tsconfig-json': {
            defaultDescription: './tsconfig.json',
            describe: 'Path to tsconfig.json',
            group: NAME_GROUP_VALIDATE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        typedoc: {
            default: true,
            description: 'Validate TypoDoc config',
            group: NAME_GROUP_VALIDATE,
            type: 'boolean',
        },
        'typedoc-json': {
            defaultDescription: './typedoc.json',
            describe: 'Path to typedoc.json',
            group: NAME_GROUP_VALIDATE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        typescript: {
            default: true,
            description: 'Validate TypeScript config',
            group: NAME_GROUP_VALIDATE,
            type: 'boolean',
        },
    }), async (argv) => {
        if (!argv.python && !argv.typedoc && !argv.typescript) {
            throw new Error('No validation targets specified; one or more of --python, --typescript or --typedoc must be provided');
        }
        await (0, validate_1.validate)(argv);
    })
        .command('build-reference', 'Build API reference docs', (yargs) => yargs.options({
        'package-json': {
            defaultDescription: './package.json',
            describe: 'Path to package.json',
            group: NAME_GROUP_BUILD_REFERENCE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        title: {
            defaultDescription: '(extension package name)',
            describe: 'Title of the API reference',
            group: NAME_GROUP_BUILD_REFERENCE,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        'tsconfig-json': {
            defaultDescription: './tsconfig.json',
            describe: 'Path to tsconfig.json',
            group: NAME_GROUP_BUILD_REFERENCE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        'typedoc-json': {
            defaultDescription: './typedoc.json',
            describe: 'Path to typedoc.json',
            group: NAME_GROUP_BUILD_REFERENCE,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
    }), async (argv) => {
        await (0, build_1.buildReference)(argv);
    })
        .command('init', 'Initialize package for docs', (yargs) => yargs.options({
        copyright: {
            descripiton: 'Copyright notice',
            group: NAME_GROUP_INIT_MKDOCS,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        dir: {
            default: '.',
            defaultDescription: '(current directory)',
            description: 'Directory of package',
            group: NAME_GROUP_INIT_PATHS,
            normalize: true,
            type: 'string',
        },
        'dry-run': {
            describe: 'Do not write any files; show what would be done',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
        force: {
            alias: 'f',
            describe: 'Overwrite existing configurations',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
        include: {
            alias: 'i',
            array: true,
            coerce: (value) => lodash_1.default.castArray(value),
            description: 'Files to include in compilation (globs OK)',
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        mkdocs: {
            default: true,
            description: 'Create mkdocs.yml if needed',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
        'mkdocs-yml': {
            defaultDescription: './mkdocs.yml',
            description: 'Path to mkdocs.yml',
            group: NAME_GROUP_INIT_PATHS,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        'package-json': {
            defaultDescription: './package.json',
            describe: 'Path to package.json',
            group: NAME_GROUP_INIT_PATHS,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        python: {
            default: true,
            description: 'Install Python dependencies if needed',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
        'python-path': {
            defaultDescription: '(derived from shell)',
            description: 'Path to python 3 executable',
            group: NAME_GROUP_INIT_PATHS,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        'repo-name': {
            defaultDescription: '(derived from --repo-url)',
            description: 'Name of extension repository',
            group: NAME_GROUP_INIT_MKDOCS,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        'repo-url': {
            defaultDescription: '(from package.json)',
            description: 'URL of extension repository',
            group: NAME_GROUP_INIT_MKDOCS,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        'site-description': {
            defaultDescription: '(from package.json)',
            description: 'Site description',
            group: NAME_GROUP_INIT_MKDOCS,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        'site-name': {
            defaultDescription: '(extension package name)',
            description: 'Name of site',
            group: NAME_GROUP_INIT_MKDOCS,
            nargs: 1,
            requiresArg: true,
            type: 'string',
        },
        'tsconfig-json': {
            defaultDescription: './tsconfig.json',
            describe: 'Path to tsconfig.json',
            group: NAME_GROUP_INIT_PATHS,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        typedoc: {
            default: true,
            description: 'Create typedoc.json if needed',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
        'typedoc-json': {
            defaultDescription: './typedoc.json',
            describe: 'Path to typedoc.json',
            group: NAME_GROUP_INIT_PATHS,
            nargs: 1,
            normalize: true,
            requiresArg: true,
            type: 'string',
        },
        typescript: {
            default: true,
            description: 'Create tsconfig.json if needed',
            group: NAME_GROUP_INIT_BEHAVIOR,
            type: 'boolean',
        },
    }), async (argv) => {
        await (0, init_1.init)({ ...argv, overwrite: argv.force, cwd: argv.dir });
        logger_1.default.success('Done (%dms)', done());
    })
        .options({
        verbose: {
            alias: 'V',
            type: 'boolean',
            describe: 'Alias for --log-level=debug',
        },
        'log-level': {
            alias: 'L',
            choices: ['debug', 'info', 'warn', 'error', 'silent'],
            default: 'info',
            describe: 'Sets the log level',
            coerce: lodash_1.default.identity,
        },
    })
        .middleware(
    /**
     * Configures logging; `--verbose` implies `--log-level=debug`
     */
    (argv) => {
        const { logLevel, verbose } = argv;
        logger_1.default.level = verbose ? LogLevelName.debug : LogLevelName[logLevel];
    })
        .fail(
    /**
     * Custom failure handler so we can log nicely.
     */
    (msg, error) => {
        // if it is a DocutilsError, it has nothing to do with the CLI
        if (error instanceof error_1.DocutilsError) {
            logger_1.default.error(error.message);
        }
        else {
            y.showHelp();
            logger_1.default.error(msg ?? error.message);
        }
        y.exit(1, error);
    })
        // at least one command is required (but not for --version or --help)
        .demandCommand(1)
        // fail if unknown option or command is provided
        .strict()
        .parseAsync();
}
exports.main = main;
if (require.main === module) {
    // eslint-disable-next-line promise/prefer-await-to-then
    main().catch((err) => {
        logger_1.default.error('Caught otherwise-unhandled rejection (this is probably a bug):', err);
    });
}
//# sourceMappingURL=cli.js.map