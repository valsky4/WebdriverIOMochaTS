"use strict";
/**
 * Handles updating/adding the `nav` property of `mkdocs.yml`, based on the output of `typedoc`;
 * specifically, the command documentation generated by `@appium/typedoc-plugin-appium`.
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateNav = void 0;
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const node_path_1 = __importDefault(require("node:path"));
const constants_1 = require("./constants");
const error_1 = require("./error");
const fs_1 = require("./fs");
const logger_1 = __importDefault(require("./logger"));
const util_1 = require("./util");
const DEFAULT_REFERENCE_HEADER = 'Reference';
const log = logger_1.default.withTag('mkdocs-nav');
/**
 * Update the `nav` property of `mkdocs.yml` with a list of "command" files generated by TypeDoc via `@appium/typedoc-plugin-appium`
 * @param opts - Options
 * @todo implement `dryRun` option
 */
async function updateNav({ cwd = process.cwd(), mkdocsYml: mkDocsYmlPath, referenceHeader = DEFAULT_REFERENCE_HEADER, noReferenceHeader = false, typedocJson: typeDocJsonPath, dryRun = false, } = {}) {
    [mkDocsYmlPath, typeDocJsonPath] = await Promise.all([
        mkDocsYmlPath ?? (0, fs_1.findMkDocsYml)(cwd),
        typeDocJsonPath ?? (0, fs_1.findTypeDocJsonPath)(cwd),
    ]);
    if (!mkDocsYmlPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_MKDOCS_YML} from ${cwd};  run "${constants_1.NAME_BIN} init" to create it`);
    }
    if (!typeDocJsonPath) {
        throw new error_1.DocutilsError(`Could not find ${constants_1.NAME_TYPEDOC_JSON} from ${cwd};  run "${constants_1.NAME_BIN} init" to create it`);
    }
    const relativePath = (0, util_1.relative)(cwd);
    const relMkDocsYmlPath = relativePath(mkDocsYmlPath);
    const typeDocJson = (0, fs_1.readTypedocJson)(typeDocJsonPath);
    const mkDocsYml = (await (0, fs_1.readYaml)(mkDocsYmlPath));
    const findRefDictIndex = lodash_1.default.partial(lodash_1.default.findIndex, lodash_1.default, lodash_1.default.overEvery([lodash_1.default.isObject, lodash_1.default.partial(lodash_1.default.has, lodash_1.default, referenceHeader)]));
    /**
     * Absolute path to `typedoc.json`
     */
    const absTypeDocJsonPath = node_path_1.default.isAbsolute(typeDocJsonPath)
        ? typeDocJsonPath
        : node_path_1.default.resolve(cwd, typeDocJsonPath);
    /**
     * Absolute path to TypeDoc's output directory (`out`)
     */
    const typeDocOutDir = node_path_1.default.resolve(node_path_1.default.dirname(absTypeDocJsonPath), typeDocJson.out ? typeDocJson.out : constants_1.DEFAULT_REL_TYPEDOC_OUT_PATH);
    /**
     * Absolute path to `mkdocs.yml`
     */
    const absMkdocsYmlPath = node_path_1.default.isAbsolute(mkDocsYmlPath)
        ? mkDocsYmlPath
        : node_path_1.default.resolve(cwd, mkDocsYmlPath);
    const { docs_dir: docsDir, nav = [] } = mkDocsYml;
    /**
     * Absolute path to the directory containing MkDocs input docs
     */
    const mkDocsDocsDir = node_path_1.default.resolve(node_path_1.default.dirname(absMkdocsYmlPath), docsDir ?? 'docs');
    /**
     * The dir we need to prepend to all entries within `nav`
     */
    const relReferenceDir = node_path_1.default.relative(mkDocsDocsDir, typeDocOutDir);
    const partitionRefArray = lodash_1.default.partialRight(lodash_1.default.partition, lodash_1.default.partialRight(lodash_1.default.startsWith, `${relReferenceDir}/`));
    const newRefFilepaths = [];
    // TODO: this doesn't respect the 'commandsDir' option for typedoc-plugin-appium.  in fact,
    // typeDocJson does not even include it, because it's unknown.  I suppose that will mean we need
    // to load plugins, but that means bootstrapping TypeDoc entirely just to read a `typedoc.json`
    // file, which is slow.
    const commandDir = node_path_1.default.join(typeDocOutDir, 'commands');
    const relCommandDir = node_path_1.default.relative(mkDocsDocsDir, commandDir);
    const commandDocFileEnts = await support_1.fs.readdir(commandDir, { withFileTypes: true });
    if (!commandDocFileEnts.length) {
        log.warn('No reference API docs were found in %s; skipping navigation update', commandDir);
        return;
    }
    for (const ent of commandDocFileEnts) {
        if (ent.isFile() && ent.name.endsWith('.md')) {
            newRefFilepaths.push(node_path_1.default.join(relCommandDir, ent.name));
        }
    }
    log.debug('New reference filepaths: %O', newRefFilepaths);
    const navUsesHeaders = noReferenceHeader || !(0, util_1.isStringArray)(nav);
    let shouldWriteMkDocsYml = false;
    let refFilepaths;
    let nonRefFilepaths;
    const refDictIdx = findRefDictIndex(nav);
    if (refDictIdx >= 0) {
        const refDict = nav[refDictIdx];
        const refArray = refDict[referenceHeader];
        [refFilepaths, nonRefFilepaths] = partitionRefArray(refArray);
    }
    else {
        [refFilepaths, nonRefFilepaths] = partitionRefArray(nav);
    }
    const symmetricDiff = lodash_1.default.xor(newRefFilepaths, refFilepaths);
    if (symmetricDiff.length) {
        log.debug('Difference in old nav vs new: %O', symmetricDiff);
        shouldWriteMkDocsYml = true;
        if (navUsesHeaders) {
            if (refDictIdx >= 0) {
                const res = [...nonRefFilepaths, ...newRefFilepaths];
                mkDocsYml.nav[refDictIdx][referenceHeader] = res;
                log.debug('Replaced "%s" section with %O', referenceHeader, res);
            }
            else {
                mkDocsYml.nav = [...nonRefFilepaths, { [referenceHeader]: newRefFilepaths }];
                log.debug('Added "%s" section with %O', referenceHeader, newRefFilepaths);
            }
        }
        else {
            mkDocsYml.nav = [...nonRefFilepaths, ...newRefFilepaths];
            log.debug('Replaced nav with %O', mkDocsYml.nav);
        }
    }
    if (shouldWriteMkDocsYml) {
        const yaml = (0, fs_1.stringifyYaml)(mkDocsYml);
        log.debug(yaml);
        await (0, fs_1.safeWriteFile)(mkDocsYmlPath, yaml, true);
        log.success('Updated navigation for reference documents in %s', relMkDocsYmlPath);
    }
    else {
        log.info('No changes to navigation for reference documents in %s', relMkDocsYmlPath);
    }
}
exports.updateNav = updateNav;
//# sourceMappingURL=nav.js.map