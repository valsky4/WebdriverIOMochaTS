/**
 * Utilities to derive comments from various sources
 * @module
 */
import { ValueOf } from 'type-fest';
import { Comment, CommentTag } from 'typedoc';
export declare const NAME_EXAMPLE_TAG = "@example";
/**
 * Languages which can be used in example code blocks
 *
 * The key is the identifier used in a fenced code block, and the value is the "display" value
 */
export declare const ExampleLanguage: {
    readonly ts: "TypeScript";
    readonly typescript: "TypeScript";
    readonly js: "JavaScript";
    readonly javascript: "JavaScript";
    readonly py: "Python";
    readonly python: "Python";
    readonly rb: "Ruby";
    readonly ruby: "Ruby";
    readonly java: "Java";
};
/**
 * A wrapper around a found {@linkcode Comment} which also contains a {@linkcode CommentSourceType}
 * so we can observe where the `Comment` came from.
 */
export interface CommentData {
    comment: Comment;
    commentSource: CommentSourceType;
}
/**
 * This is basically a fenced code block split into two portions: the text itself and the language
 * specified in the opening fence.  Part of {@linkcode ExtractedExamples}
 */
export interface Example {
    text: string;
    lang: ValueOf<typeof ExampleLanguage>;
}
/**
 * A pair of a comment and any examples which were removed from it.  Returned by {@linkcode extractExamples}
 */
export interface ExtractedExamples {
    examples?: Example[];
    comment: Comment;
}
/**
 * Clones a comment. Mostly. I think.
 * @param comment Comment to clone
 * @param blockTags Block tags to use; if not provided, the comment's block tags will be used (these
 * are also cloned)
 * @returns A new comment
 */
export declare function cloneComment(comment: Comment, blockTags?: CommentTag[]): Comment;
/**
 * Finds any `@example` tags within a comment and creates an {@linkcode ExtractedExamples} object
 * for them. Creates a new comment with the examples removed, so we can handle them in a
 * custom way via our theme.
 *
 * Note that the same `Comment` can be passed multiple times (if it is displayed in multiple
 * modules).  Our choices are either to a) clone the comment each time, or b) memoize the function
 * in order to avoid a problem wherein the comment has its examples extracted on the first call, but
 * subsequent calls will not contain any examples (since they've already been extracted).  It may be
 * more memory-friendly to memoize, but it may not be the safest thing to do (unclear).
 *
 * @param comment A comment to extract examples from
 * @returns New comment (with examples removed)
 */
export declare const extractExamples: (comment?: Comment) => ExtractedExamples | undefined;
//# sourceMappingURL=comment.d.ts.map