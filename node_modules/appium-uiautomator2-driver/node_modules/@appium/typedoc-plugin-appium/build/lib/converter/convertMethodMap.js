"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertMethodMap = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const comment_1 = require("./comment");
const utils_1 = require("./utils");
const converters_1 = require("./converters");
/**
 * Extracts information about `MethodMap` objects
 * @param parentRefl - Some reflection we want to inspect. Could refer to a module or a class
 * @returns Lookup of routes to {@linkcode CommandSet} objects
 */
function convertMethodMap(log, methodMapRef, parentRefl, methods, knownMethods = new Map()) {
    const routes = new Map();
    const routeProps = (0, utils_1.filterChildrenByKind)(methodMapRef, typedoc_1.ReflectionKind.Property);
    if (!routeProps.length) {
        log.warn('(%s) No routes found in MethodMap; skipping', parentRefl.name);
        return routes;
    }
    for (const routeProp of routeProps) {
        const { originalName: route } = routeProp;
        if (!(0, guards_1.isRoutePropDeclarationReflection)(routeProp)) {
            log.warn('Empty route in %s.%s', parentRefl.name, route);
            continue;
        }
        const httpMethodProps = (0, utils_1.filterChildrenByGuard)(routeProp, guards_1.isHTTPMethodDeclarationReflection);
        if (!httpMethodProps.length) {
            log.warn('No HTTP methods found in route %s.%s', parentRefl.name, route);
            continue;
        }
        for (const httpMethodProp of httpMethodProps) {
            const { comment: mapComment, name: httpMethod } = httpMethodProp;
            const commandProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isCommandPropDeclarationReflection);
            // commandProp is optional.
            if (!commandProp) {
                continue;
            }
            if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
                log.warn('Empty command name found in %s.%s.%s', parentRefl.name, route, httpMethod);
                continue;
            }
            const command = String(commandProp.type.value);
            const method = methods.get(command)?.method;
            const commentData = (0, comment_1.deriveComment)(command, knownMethods, method, mapComment);
            const payloadParamsProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isExecMethodDefParamsPropDeclarationReflection);
            const requiredParams = (0, converters_1.convertRequiredCommandParams)(payloadParamsProp);
            const optionalParams = (0, converters_1.convertOptionalCommandParams)(payloadParamsProp);
            const commandSet = routes.get(route) ?? new Set();
            commandSet.add(new model_1.CommandData(log, command, httpMethod, route, {
                requiredParams,
                optionalParams,
                comment: commentData?.comment,
                commentSource: commentData?.commentSource,
                refl: method,
                parentRefl,
            }));
            routes.set(route, commandSet);
        }
    }
    return routes;
}
exports.convertMethodMap = convertMethodMap;
//# sourceMappingURL=convertMethodMap.js.map