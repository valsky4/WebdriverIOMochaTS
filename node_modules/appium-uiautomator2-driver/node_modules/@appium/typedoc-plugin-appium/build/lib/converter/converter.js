"use strict";
/**
 * Converts code parsed by TypeDoc into a data structure describing the commands and execute methods, which will later be used to create new {@linkcode DeclarationReflection} instances in the TypeDoc context.
 *
 * The logic in this module is highly dependent on Appium's extension API, and is further dependent on specific usages of TS types.  Anything that will be parsed successfully by this module must use a `const` type alias in TS parlance.  For example:
 *
 * ```ts
 * const METHOD_MAP = {
 *   '/status': {
 *     GET: {command: 'getStatus'}
 *   },
 *   // ...
 * } as const; // <-- required
 * ```
 * @module
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _CommandConverter_instances, _CommandConverter_ctx, _CommandConverter_log, _CommandConverter_convertBaseDriver, _CommandConverter_convertCommandParams, _CommandConverter_convertExecuteMethodMap, _CommandConverter_convertMethodMap, _CommandConverter_convertModuleClasses, _CommandConverter_convertOptionalCommandParams, _CommandConverter_convertRequiredCommandParams;
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertCommands = exports.CommandConverter = exports.NAME_BUILTIN_COMMAND_MODULE = exports.NAME_PAYLOAD_PARAMS = exports.NAME_COMMAND = exports.NAME_PARAMS = exports.NAME_OPTIONAL = exports.NAME_REQUIRED = exports.NAME_METHOD_MAP = exports.NAME_EXECUTE_METHOD_MAP = exports.NAME_NEW_METHOD_MAP = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
/**
 * Name of the static `newMethodMap` property in a Driver
 */
exports.NAME_NEW_METHOD_MAP = 'newMethodMap';
/**
 * Name of the static `executeMethodMap` property in a Driver
 */
exports.NAME_EXECUTE_METHOD_MAP = 'executeMethodMap';
/**
 * Name of the builtin method map in `@appium/base-driver`
 */
exports.NAME_METHOD_MAP = 'METHOD_MAP';
/**
 * Name of the field in a method map's parameters prop which contains required parameters
 */
exports.NAME_REQUIRED = 'required';
/**
 * Name of the field in a method map's parameters prop which contains optional parameters
 */
exports.NAME_OPTIONAL = 'optional';
/**
 * Name of the field in an _execute_ method map which contains parameters
 */
exports.NAME_PARAMS = 'params';
/**
 * Name of the command in a method map
 */
exports.NAME_COMMAND = 'command';
/**
 * Name of the field in a _regular_ method map which contains parameters
 */
exports.NAME_PAYLOAD_PARAMS = 'payloadParams';
/**
 * Name of the module which contains the builtin method map
 */
exports.NAME_BUILTIN_COMMAND_MODULE = '@appium/base-driver';
/**
 * Converts declarations to information about Appium commands
 */
class CommandConverter {
    /**
     * Creates a child logger for this instance
     * @param ctx Typedoc Context
     * @param log Logger
     */
    constructor(ctx, log) {
        _CommandConverter_instances.add(this);
        /**
         * The project context of TypeDoc
         */
        _CommandConverter_ctx.set(this, void 0);
        /**
         * Custom logger
         */
        _CommandConverter_log.set(this, void 0);
        __classPrivateFieldSet(this, _CommandConverter_ctx, ctx, "f");
        __classPrivateFieldSet(this, _CommandConverter_log, log.createChildLogger('converter'), "f");
    }
    /**
     * Converts declarations into command information
     *
     * @returns Command info for entire project
     */
    convert() {
        const ctx = __classPrivateFieldGet(this, _CommandConverter_ctx, "f");
        const { project } = ctx;
        const projectCommands = new Map();
        // handle baseDriver if it's present
        const baseDriver = project.getChildByName(exports.NAME_BUILTIN_COMMAND_MODULE);
        if (baseDriver && (0, guards_1.isBaseDriverDeclarationReflection)(baseDriver)) {
            __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('Found %s', exports.NAME_BUILTIN_COMMAND_MODULE);
            projectCommands.set(baseDriver, __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertBaseDriver).call(this, baseDriver));
        }
        else {
            __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('Did not find %s', exports.NAME_BUILTIN_COMMAND_MODULE);
        }
        // convert all modules (or just project if no modules)
        const modules = project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
        if (modules.length) {
            for (const mod of modules) {
                __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('Converting module %s', mod.name);
                const cmdInfo = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertModuleClasses).call(this, mod);
                if (cmdInfo.hasData) {
                    projectCommands.set(mod, __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertModuleClasses).call(this, mod));
                }
                __classPrivateFieldGet(this, _CommandConverter_log, "f").info('Converted module %s', mod.name);
            }
        }
        else {
            projectCommands.set(project, __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertModuleClasses).call(this, project));
        }
        __classPrivateFieldGet(this, _CommandConverter_log, "f").info('Found commands in %d module(s)', projectCommands.size);
        return projectCommands;
    }
}
exports.CommandConverter = CommandConverter;
_CommandConverter_ctx = new WeakMap(), _CommandConverter_log = new WeakMap(), _CommandConverter_instances = new WeakSet(), _CommandConverter_convertBaseDriver = function _CommandConverter_convertBaseDriver(baseDriver) {
    const baseDriverRoutes = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertMethodMap).call(this, baseDriver);
    if (!baseDriverRoutes.size) {
        throw new TypeError(`Could not find any commands in BaseDriver!?`);
    }
    // no execute commands in BaseDriver
    return new model_1.CommandInfo(baseDriverRoutes);
}, _CommandConverter_convertCommandParams = function _CommandConverter_convertCommandParams(propName, refl) {
    if (!refl) {
        return [];
    }
    const props = findChildByNameAndGuard(refl, propName, guards_1.isMethodDefParamNamesDeclarationReflection);
    if (!props) {
        return [];
    }
    return props.type.target.elements.reduce((names, el) => {
        const stringValue = String(el.value);
        if (stringValue) {
            names.push(stringValue);
        }
        return names;
    }, []);
}, _CommandConverter_convertExecuteMethodMap = function _CommandConverter_convertExecuteMethodMap(refl) {
    const executeMethodMap = findChildByGuard(refl, guards_1.isExecMethodDefReflection);
    const commandRefs = new Set();
    if (!executeMethodMap) {
        // no execute commands in this class
        return commandRefs;
    }
    const newMethodProps = filterChildrenByKind(executeMethodMap, typedoc_1.ReflectionKind.Property);
    for (const newMethodProp of newMethodProps) {
        const { comment, originalName: script } = newMethodProp;
        const commandProp = findChildByGuard(newMethodProp, guards_1.isCommandPropDeclarationReflection);
        if (!commandProp) {
            // this is unusual
            __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('Execute method map in %s has no "command" property for %s', refl.name, script);
            continue;
        }
        if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
            __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('Execute method map in %s has an empty or invalid "command" property for %s', refl.name, script);
            continue;
        }
        const command = String(commandProp.type.value);
        const paramsProp = findChildByGuard(newMethodProp, guards_1.isExecMethodDefParamsPropDeclarationReflection);
        const requiredParams = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertRequiredCommandParams).call(this, paramsProp);
        const optionalParams = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertOptionalCommandParams).call(this, paramsProp);
        commandRefs.add({
            command,
            requiredParams,
            optionalParams,
            script,
            comment,
        });
    }
    return commandRefs;
}, _CommandConverter_convertMethodMap = function _CommandConverter_convertMethodMap(refl) {
    const routes = new Map();
    const methodMap = (0, guards_1.isBaseDriverDeclarationReflection)(refl)
        ? refl.getChildByName(exports.NAME_METHOD_MAP)
        : refl.getChildByName(exports.NAME_NEW_METHOD_MAP);
    if (!(0, guards_1.isMethodMapDeclarationReflection)(methodMap)) {
        // this is not unusual
        __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('No {MethodMap} found in class %s', refl.name);
        return routes;
    }
    const routeProps = filterChildrenByKind(methodMap, typedoc_1.ReflectionKind.Property);
    if (!routeProps.length) {
        __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('No routes found in {MethodMap} of class %s', refl.name);
        return routes;
    }
    for (const routeProp of routeProps) {
        const { originalName: route } = routeProp;
        if (!(0, guards_1.isRoutePropDeclarationReflection)(routeProp)) {
            __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('Empty route in %s.%s', refl.name, route);
            continue;
        }
        const httpMethodProps = filterChildrenByGuard(routeProp, guards_1.isHTTPMethodDeclarationReflection);
        if (!httpMethodProps.length) {
            __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('No HTTP methods found in route %s.%s', refl.name, route);
            continue;
        }
        for (const httpMethodProp of httpMethodProps) {
            const { comment, originalName: httpMethod } = httpMethodProp;
            const commandProp = findChildByGuard(httpMethodProp, guards_1.isCommandPropDeclarationReflection);
            // commandProp is optional.
            if (!commandProp) {
                continue;
            }
            if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
                __classPrivateFieldGet(this, _CommandConverter_log, "f").warn('Empty command name found in %s.%s.%s', refl.name, route, httpMethod);
                continue;
            }
            const command = String(commandProp.type.value);
            const payloadParamsProp = findChildByGuard(httpMethodProp, guards_1.isExecMethodDefParamsPropDeclarationReflection);
            const requiredParams = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertRequiredCommandParams).call(this, payloadParamsProp);
            const optionalParams = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertOptionalCommandParams).call(this, payloadParamsProp);
            const commandMap = routes.get(route) ?? new Map();
            commandMap.set(command, {
                command,
                requiredParams,
                optionalParams,
                httpMethod,
                route,
                comment,
            });
            routes.set(route, commandMap);
        }
    }
    return routes;
}, _CommandConverter_convertModuleClasses = function _CommandConverter_convertModuleClasses(parent) {
    let routes = new Map();
    let executeMethods = new Set();
    const classReflections = parent.getChildrenByKind(typedoc_1.ReflectionKind.Class);
    for (const classRefl of classReflections) {
        __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('Converting class %s', classRefl.name);
        const newMethodMap = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertMethodMap).call(this, classRefl);
        if (newMethodMap.size) {
            routes = new Map([...routes, ...newMethodMap]);
        }
        const executeMethodMap = __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertExecuteMethodMap).call(this, classRefl);
        if (executeMethodMap.size) {
            executeMethods = new Set([...executeMethods, ...executeMethodMap]);
        }
        __classPrivateFieldGet(this, _CommandConverter_log, "f").verbose('Converted class %s', classRefl.name);
    }
    return new model_1.CommandInfo(routes, executeMethods);
}, _CommandConverter_convertOptionalCommandParams = function _CommandConverter_convertOptionalCommandParams(methodDefRefl) {
    return __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertCommandParams).call(this, exports.NAME_OPTIONAL, methodDefRefl);
}, _CommandConverter_convertRequiredCommandParams = function _CommandConverter_convertRequiredCommandParams(methodDefRefl) {
    return __classPrivateFieldGet(this, _CommandConverter_instances, "m", _CommandConverter_convertCommandParams).call(this, exports.NAME_REQUIRED, methodDefRefl);
};
/**
 * Converts declarations into information about the commands found within
 * @param ctx - Current TypeDoc context
 * @param log - Logger
 * @returns All commands found in the project
 */
function convertCommands(ctx, log) {
    return new CommandConverter(ctx, log).convert();
}
exports.convertCommands = convertCommands;
/**
 * Finds a child of a reflection by name and type guard
 * @param refl - Reflection to check
 * @param name - Name of child
 * @param guard - Guard function to check child
 * @returns Child if found, `undefined` otherwise
 * @internal
 */
function findChildByNameAndGuard(refl, name, guard) {
    return ((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.find((child) => child.name === name && guard(child))
        : refl.children?.find((child) => child.name === name && guard(child)));
}
/**
 * Finds a child of a reflection by type guard
 * @param refl - Reflection to check
 * @param guard - Guard function to check child
 * @returns Child if found, `undefined` otherwise
 * @internal
 */
function findChildByGuard(refl, guard) {
    return ((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.find(guard)
        : refl.children?.find(guard));
}
/**
 * Filters children of a reflection by kind and whether they are of type {@linkcode DeclarationReflectionWithReflectedType}
 * @param refl - Reflection to check
 * @param kind - Kind of child
 * @returns Filtered children, if any
 * @internal
 */
function filterChildrenByKind(refl, kind) {
    return (((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.getChildrenByKind(kind)
        : refl.getChildrenByKind(kind)) ?? []);
}
/**
 * Filters children by a type guard
 * @param refl - Reflection to check
 * @param guard - Type guard function
 * @returns Filtered children, if any
 * @internal
 */
function filterChildrenByGuard(refl, guard) {
    return (((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.filter(guard)
        : refl.children?.filter(guard)) ?? []);
}
//# sourceMappingURL=converter.js.map