"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertOverrides = void 0;
const lodash_1 = __importDefault(require("lodash"));
const comment_1 = require("./comment");
/**
 * Returns routes pulled from `builtinCommands` if the driver implements them as methods.
 *
 * This makes up for the fact that `newMethodMap` only defines _new_ methods, not ones that already
 * exist in `@appium/base-driver`.
 *
 * Sorry about all the arguments!
 * @param args Required arguments
 * @returns More routes pulled from `builtinCommands`, if the driver implements them
 */
function convertOverrides({ log, parentRefl, classMethods, builtinMethods, newRouteMap, newExecMethodMap, builtinCommands, }) {
    const routes = new Map();
    /**
     * All command/method names associated with execute methods
     */
    const execMethodNames = [...newExecMethodMap].map((execData) => execData.command);
    /**
     * All method names in the class
     */
    const methodNames = [...classMethods.keys()];
    /**
     * All methods in the class which are not associated with execute methods
     */
    const methodsLessExecCommands = lodash_1.default.difference(methodNames, execMethodNames);
    /**
     * All methods in the class within its `newMethodMap`
     */
    const methodsInMethodMap = [...newRouteMap.values()].flatMap((commandSet) => [...commandSet].map((commandData) => commandData.command));
    /**
     * All methods in the class which are not associated with execute methods nor the class' method map
     */
    const unknownMethods = new Set(lodash_1.default.difference(methodsLessExecCommands, methodsInMethodMap));
    // this discovers all of the ExternalDriver methods implemented in the driver class
    // and adds them to the routes map.
    for (const command of unknownMethods) {
        const builtinRoutes = builtinCommands.routesByCommandName.get(command);
        if (!builtinMethods.has(command) || !builtinRoutes) {
            // actually unknown method
            continue;
        }
        // the method is in ExternalDriver, so remove it
        unknownMethods.delete(command);
        for (const route of builtinRoutes) {
            const newCommandSet = new Set();
            // this must be defined, because if it wasn't then builtinRoutes would be empty and we'd continue the loop
            const commandSet = builtinCommands.routeMap.get(route);
            for (const commandData of commandSet) {
                const method = classMethods.get(command)?.method;
                if (!method) {
                    continue;
                }
                const commentData = (0, comment_1.deriveComment)(command, builtinMethods, method, commandData.comment);
                const newCommandData = commandData.clone({
                    refl: commandData.methodRefl,
                    parentRefl,
                    ...commentData,
                });
                log.verbose('(%s) Added %s route to method %s for command "%s"', parentRefl.name, commandData.httpMethod, method.name, command);
                newCommandSet.add(newCommandData);
            }
            routes.set(route, newCommandSet);
        }
    }
    if (unknownMethods.size) {
        // this is quite likely, as any async method is inspected.
        log.info('(%s) The following async methods were not found in any method map: %s', parentRefl.name, [...unknownMethods].join(', '));
    }
    return routes;
}
exports.convertOverrides = convertOverrides;
//# sourceMappingURL=converters.js.map