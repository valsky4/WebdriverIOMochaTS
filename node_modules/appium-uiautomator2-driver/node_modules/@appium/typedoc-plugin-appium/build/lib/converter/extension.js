"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ExtensionConverter_instances, _ExtensionConverter_convertModuleClasses, _ExtensionConverter_findAndConvertExecMethodMap, _ExtensionConverter_findAndConvertNewMethodMap;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionConverter = exports.NAME_BASE_PLUGIN = exports.NAME_PAYLOAD_PARAMS = exports.NAME_COMMAND = exports.NAME_PARAMS = exports.NAME_OPTIONAL = exports.NAME_REQUIRED = exports.NAME_EXECUTE_METHOD_MAP = exports.NAME_NEW_METHOD_MAP = void 0;
const lodash_1 = __importDefault(require("lodash"));
const pluralize_1 = __importDefault(require("pluralize"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const base_converter_1 = require("./base-converter");
const overrides_1 = require("./overrides");
const exec_method_map_1 = require("./exec-method-map");
const method_map_1 = require("./method-map");
const utils_1 = require("./utils");
/**
 * Name of the static `newMethodMap` property in a Driver or Plugin
 */
exports.NAME_NEW_METHOD_MAP = 'newMethodMap';
/**
 * Name of the static `executeMethodMap` property in a Driver
 */
exports.NAME_EXECUTE_METHOD_MAP = 'executeMethodMap';
/**
 * Name of the field in a method map's parameters prop which contains required parameters
 */
exports.NAME_REQUIRED = 'required';
/**
 * Name of the field in a method map's parameters prop which contains optional parameters
 */
exports.NAME_OPTIONAL = 'optional';
/**
 * Name of the field in an _execute_ method map which contains parameters
 */
exports.NAME_PARAMS = 'params';
/**
 * Name of the command in a method map
 */
exports.NAME_COMMAND = 'command';
/**
 * Name of the field in a _regular_ method map which contains parameters
 */
exports.NAME_PAYLOAD_PARAMS = 'payloadParams';
exports.NAME_BASE_PLUGIN = 'BasePlugin';
/**
 * Converts declarations to information about Appium commands
 */
class ExtensionConverter extends base_converter_1.BaseConverter {
    /**
     * Creates a child logger for this instance
     * @param ctx Typedoc Context
     * @param log Logger
     */
    constructor(ctx, log, knownMethods, builtinCommands) {
        super(ctx, log.createChildLogger('extension'), builtinCommands);
        this.knownMethods = knownMethods;
        this.builtinCommands = builtinCommands;
        _ExtensionConverter_instances.add(this);
    }
    /**
     * Converts declarations into command information
     *
     * @returns Command info for entire project
     */
    convert() {
        const ctx = this.ctx;
        const { project } = ctx;
        const projectCommands = new model_1.ProjectCommands();
        // convert all modules (or just project if no modules)
        const modules = project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
        if (modules.length) {
            for (const mod of modules) {
                const log = this.log.createChildLogger(mod.name);
                log.verbose('Begin conversion');
                const cmdInfo = __classPrivateFieldGet(this, _ExtensionConverter_instances, "m", _ExtensionConverter_convertModuleClasses).call(this, mod, log);
                projectCommands.set(mod.name, cmdInfo);
                log.verbose('End conversion');
            }
        }
        else {
            const log = this.log.createChildLogger(project.name);
            log.verbose('Begin conversion');
            const cmdInfo = __classPrivateFieldGet(this, _ExtensionConverter_instances, "m", _ExtensionConverter_convertModuleClasses).call(this, project, log);
            projectCommands.set(project.name, cmdInfo);
            log.verbose('End conversion');
        }
        if (projectCommands.size) {
            const routeSum = lodash_1.default.sumBy([...projectCommands], ([, info]) => info.routeMap.size);
            const execMethodSum = lodash_1.default.sumBy([...projectCommands], ([, info]) => info.execMethodDataSet.size);
            this.log.info('Found %s and %s in %s', (0, pluralize_1.default)('command', routeSum, true), (0, pluralize_1.default)('execute method', execMethodSum, true), (0, pluralize_1.default)('module', modules.length, true));
        }
        else {
            this.log.error('No commands nor execute methods found in entire project!');
        }
        return projectCommands;
    }
}
exports.ExtensionConverter = ExtensionConverter;
_ExtensionConverter_instances = new WeakSet(), _ExtensionConverter_convertModuleClasses = function _ExtensionConverter_convertModuleClasses(parentRefl, log) {
    let routeMap = new Map();
    let execMethodData = new Set();
    const classReflections = (0, utils_1.filterChildrenByGuard)(parentRefl, guards_1.isClassDeclarationReflection);
    for (const classRefl of classReflections) {
        const isPlugin = (0, guards_1.isBasePluginConstructorDeclarationReflection)((0, utils_1.findChildByGuard)(classRefl, guards_1.isConstructorDeclarationReflection));
        const methods = (0, utils_1.findAsyncMethodsInReflection)(classRefl, this.knownMethods);
        if (!methods.size) {
            // may or may not be expected
            log.verbose('No methods found');
            continue;
        }
        log.verbose('Analyzing %s', (0, pluralize_1.default)('method', methods.size, true));
        const newRouteMap = __classPrivateFieldGet(this, _ExtensionConverter_instances, "m", _ExtensionConverter_findAndConvertNewMethodMap).call(this, classRefl, methods, log, isPlugin);
        routeMap = new Map([...routeMap, ...newRouteMap]);
        const newExecMethodData = __classPrivateFieldGet(this, _ExtensionConverter_instances, "m", _ExtensionConverter_findAndConvertExecMethodMap).call(this, classRefl, methods, log, isPlugin);
        execMethodData = new Set([...execMethodData, ...newExecMethodData]);
        const overriddenRouteMap = this.builtinCommands
            ? (0, overrides_1.convertOverrides)({
                log,
                parentRefl: classRefl,
                classMethods: methods,
                builtinMethods: this.knownMethods,
                newRouteMap,
                newExecMethodMap: execMethodData,
                builtinCommands: this.builtinCommands,
            })
            : new Map();
        routeMap = new Map([...routeMap, ...overriddenRouteMap]);
        log.verbose('Done; found %s and %s', (0, pluralize_1.default)('route', newRouteMap.size + overriddenRouteMap.size, true), (0, pluralize_1.default)('execute method', newExecMethodData.size, true));
    }
    return new model_1.ModuleCommands(routeMap, execMethodData);
}, _ExtensionConverter_findAndConvertExecMethodMap = function _ExtensionConverter_findAndConvertExecMethodMap(parentRefl, methods, log, isPluginCommand) {
    const execMethodMapRefl = (0, utils_1.findChildByGuard)(parentRefl, guards_1.isExecMethodDefReflection);
    if (!execMethodMapRefl) {
        log.verbose('No execute method map found');
        return new Set();
    }
    return (0, exec_method_map_1.convertExecuteMethodMap)({
        log,
        parentRefl,
        execMethodMapRefl,
        methods,
        strict: true,
        isPluginCommand,
    });
}, _ExtensionConverter_findAndConvertNewMethodMap = function _ExtensionConverter_findAndConvertNewMethodMap(parentRefl, methods, log, isPluginCommand) {
    const newMethodMapRefl = (0, utils_1.findChildByNameAndGuard)(parentRefl, exports.NAME_NEW_METHOD_MAP, guards_1.isMethodMapDeclarationReflection);
    if (!newMethodMapRefl) {
        log.verbose('No new method map found');
        return new Map();
    }
    return (0, method_map_1.convertMethodMap)({
        log,
        methodMapRefl: newMethodMapRefl,
        parentRefl,
        methods,
        knownMethods: this.knownMethods,
        strict: true,
        isPluginCommand,
    });
};
//# sourceMappingURL=extension.js.map