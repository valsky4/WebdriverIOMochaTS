"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertMethodMap = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
const model_1 = require("../model");
const comment_1 = require("./comment");
const utils_1 = require("./utils");
/**
 * Extracts information about `MethodMap` objects
 * @param opts Options
 * @returns Lookup of routes to {@linkcode CommandSet} objects
 */
function convertMethodMap({ log, methodMapRefl, parentRefl, methods, knownMethods = new Map(), strict = false, isPluginCommand = false, }) {
    const routes = new Map();
    const routeProps = (0, utils_1.filterChildrenByKind)(methodMapRefl, typedoc_1.ReflectionKind.Property);
    if (!routeProps.length) {
        log.warn('No routes found in MethodMap; skipping');
        return routes;
    }
    for (const routeProp of routeProps) {
        const { originalName: route } = routeProp;
        if (!(0, guards_1.isRoutePropDeclarationReflection)(routeProp)) {
            log.warn('Empty route: %s', route);
            continue;
        }
        const httpMethodProps = (0, utils_1.filterChildrenByGuard)(routeProp, guards_1.isHTTPMethodDeclarationReflection);
        if (!httpMethodProps.length) {
            log.warn('No HTTP methods found in route %s', route);
            continue;
        }
        for (const httpMethodProp of httpMethodProps) {
            const { comment: mapComment, name: httpMethod } = httpMethodProp;
            const commandProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isCommandPropDeclarationReflection);
            // commandProp is optional.
            if (!commandProp) {
                continue;
            }
            if (!lodash_1.default.isString(commandProp.type.value) || lodash_1.default.isEmpty(commandProp.type.value)) {
                log.warn('Empty command name found in %s - %s', route, httpMethod);
                continue;
            }
            const command = String(commandProp.type.value);
            const method = methods.get(command);
            if (strict && !method) {
                log.warn('(%s) No method found for command "%s"; this is a bug', parentRefl.name, command);
                continue;
            }
            const commentData = (0, comment_1.deriveComment)({
                refl: method,
                comment: mapComment,
                knownMethods,
            });
            const payloadParamsProp = (0, utils_1.findChildByGuard)(httpMethodProp, guards_1.isExecMethodDefParamsPropDeclarationReflection);
            const requiredParams = (0, utils_1.convertRequiredCommandParams)(payloadParamsProp);
            const optionalParams = (0, utils_1.convertOptionalCommandParams)(payloadParamsProp);
            const commandSet = routes.get(route) ?? new Set();
            commandSet.add(new model_1.CommandData(log, command, httpMethod, route, {
                requiredParams,
                optionalParams,
                comment: commentData?.comment,
                commentSource: commentData?.commentSource,
                refl: method,
                parentRefl,
                isPluginCommand,
            }));
            log.verbose('Registered route %s %s for command "%s"', httpMethod, route, command);
            routes.set(route, commandSet);
        }
    }
    return routes;
}
exports.convertMethodMap = convertMethodMap;
//# sourceMappingURL=method-map.js.map