"use strict";
/**
 * Utilities for the various converters.
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRequiredCommandParams = exports.convertCommandParams = exports.convertOptionalCommandParams = exports.findAsyncMethodsInReflection = exports.filterChildrenByKind = exports.findChildByNameAndGuard = exports.findChildByGuard = exports.filterChildrenByGuard = exports.findParentReflectionByName = void 0;
const guards_1 = require("../guards");
const external_1 = require("./external");
function findParentReflectionByName(project, name) {
    return project.name === name ? project : project.getChildByName(name);
}
exports.findParentReflectionByName = findParentReflectionByName;
/**
 * Filters children by a type guard
 * @param refl - Reflection to check
 * @param guard - Type guard function
 * @returns Filtered children, if any
 * @internal
 */
function filterChildrenByGuard(refl, guard) {
    return (((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.filter(guard)
        : refl.children?.filter(guard)) ?? []);
}
exports.filterChildrenByGuard = filterChildrenByGuard;
/**
 * Finds a child of a reflection by type guard
 * @param refl - Reflection to check
 * @param guard - Guard function to check child
 * @returns Child if found, `undefined` otherwise
 * @internal
 */
function findChildByGuard(refl, guard) {
    return ((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.find(guard)
        : refl.children?.find(guard));
}
exports.findChildByGuard = findChildByGuard;
/**
 * Finds a child of a reflection by name and type guard
 * @param refl - Reflection to check
 * @param name - Name of child
 * @param guard - Guard function to check child
 * @returns Child if found, `undefined` otherwise
 * @internal
 */
function findChildByNameAndGuard(refl, name, guard) {
    const predicate = (child) => child.name === name && guard(child);
    return ((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.children?.find(predicate)
        : refl.children?.find(predicate));
}
exports.findChildByNameAndGuard = findChildByNameAndGuard;
/**
 * Filters children of a reflection by kind and whether they are of type {@linkcode DeclarationReflectionWithReflectedType}
 * @param refl - Reflection to check
 * @param kind - Kind of child
 * @returns Filtered children, if any
 * @internal
 */
function filterChildrenByKind(refl, kind) {
    return (((0, guards_1.isReflectionWithReflectedType)(refl)
        ? refl.type.declaration.getChildrenByKind(kind)
        : refl.getChildrenByKind(kind)) ?? []);
}
exports.filterChildrenByKind = filterChildrenByKind;
/**
 * Finds _all_ async methods in a class or interface
 * @param refl Class reflection
 * @returns Map of method names to method reflections
 */
function findAsyncMethodsInReflection(refl) {
    return new Map(filterChildrenByGuard(refl, guards_1.isAsyncMethodDeclarationReflection).map((method) => [
        method.name,
        method,
    ]));
}
exports.findAsyncMethodsInReflection = findAsyncMethodsInReflection;
/**
 * Finds "optional" params in a method definition
 * @param methodDefRefl - Reflection of a method definition
 * @returns List of optional parameters
 * @internal
 */
function convertOptionalCommandParams(methodDefRefl) {
    return convertCommandParams(external_1.NAME_OPTIONAL, methodDefRefl);
}
exports.convertOptionalCommandParams = convertOptionalCommandParams;
/**
 * Finds names of parameters of a command in a method def
 * @param propName Either required or optional params
 * @param refl Parent reflection (`params` prop of method def)
 * @returns List of parameter names
 * @internal
 */
function convertCommandParams(propName, refl) {
    if (!refl) {
        return [];
    }
    const props = findChildByNameAndGuard(refl, propName, guards_1.isMethodDefParamNamesDeclarationReflection);
    if (!props) {
        return [];
    }
    return props.type.target.elements.reduce((names, el) => {
        const stringValue = String(el.value);
        if (stringValue) {
            names.push(stringValue);
        }
        return names;
    }, []);
}
exports.convertCommandParams = convertCommandParams;
/**
 * Finds "required" params in a method definition
 * @param methodDefRefl - Reflection of a method definition
 * @returns List of required parameters
 * @internal
 */
function convertRequiredCommandParams(methodDefRefl) {
    return convertCommandParams(external_1.NAME_REQUIRED, methodDefRefl);
}
exports.convertRequiredCommandParams = convertRequiredCommandParams;
//# sourceMappingURL=utils.js.map