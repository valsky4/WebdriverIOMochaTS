"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecMethodData = exports.CommandData = exports.BaseCommandData = void 0;
const lodash_1 = __importDefault(require("lodash"));
const typedoc_1 = require("typedoc");
const guards_1 = require("../guards");
/**
 * List of fields to shallow copy from a `SignatureReflection` to a clone
 * @internal
 */
const SIGNATURE_REFLECTION_CLONE_FIELDS = [
    'anchor',
    'comment',
    'flags',
    'hasOwnDocument',
    'implementationOf',
    'inheritedFrom',
    'kindString',
    'label',
    'originalName',
    'overwrites',
    'parameters',
    'sources',
    'typeParameters',
    'url',
];
/**
 * List of fields to shallow copy from a `ParameterReflection` to a clone
 * @internal
 */
const PARAMETER_REFLECTION_CLONE_FIELDS = [
    'anchor',
    'comment',
    'cssClasses',
    'defaultValue',
    'hasOwnDocument',
    'label',
    'originalName',
    'sources',
    'type',
    'url',
];
/**
 * Abstract representation of metadata for some sort of Appium command
 */
class BaseCommandData {
    constructor(log, command, opts = {}) {
        this.command = command;
        this.optionalParams = opts.optionalParams;
        this.requiredParams = opts.requiredParams;
        this.comment = opts.comment;
        this.commentSource = opts.commentSource;
        this.methodRefl = opts.refl;
        this.parentRefl = opts.parentRefl;
        this.log = log;
        this.isPluginCommand = Boolean(opts.isPluginCommand);
    }
    /**
     * Returns `true` if the method or execute map defined parameters for this command
     */
    get hasCommandParams() {
        return Boolean(this.optionalParams?.length || this.requiredParams?.length);
    }
    /**
     * Gets a list of function parameters (for use in rendering)
     */
    get parameters() {
        return BaseCommandData.rewriteParameters(this);
    }
    /**
     * Gets the call signature (for use in rendering)
     */
    get signature() {
        return BaseCommandData.unwrapSignatureType(this);
    }
}
exports.BaseCommandData = BaseCommandData;
/**
 * Loops through signatures of the command's method declaration and returns the first that is a
 * `CallSignatureReflection` (if any).  This is what we think of when we think "function signature"
 */
BaseCommandData.findCallSignature = lodash_1.default.memoize((cmd) => cmd.methodRefl?.getAllSignatures()?.find(guards_1.isCallSignatureReflection));
/**
 * Returns a list of `ParameterReflection` objects in the command's method declaration;
 * rewrites them to prefer the method map parameter list (and the param names)
 **/
BaseCommandData.rewriteParameters = lodash_1.default.memoize((cmd) => {
    if (!cmd.hasCommandParams) {
        return [];
    }
    const sig = BaseCommandData.findCallSignature(cmd);
    if (!sig) {
        return [];
    }
    const pRefls = (cmd.isPluginCommand ? sig.parameters?.slice(2) : sig.parameters?.slice()) ?? [];
    if (pRefls.length < cmd.requiredParams.length + cmd.optionalParams.length) {
        cmd.log.warn('(%s) Method %s has fewer parameters (%d) than specified in the method map (%d)', cmd.parentRefl.name, cmd.methodRefl.name, pRefls.length, cmd.requiredParams.length + cmd.optionalParams.length);
    }
    /**
     * This loops over the command parameter names as defined in the method/execute map and attempts
     * to associate a `ParameterReflection` object with each.
     *
     * Because the command param names are essentially properties of a JSON object and the
     * `ParameterReflection` instances represent the arguments of a method, we must match them by
     * index. In JS, Required arguments always come first, so we can do those first. If there are
     * _more_ method arguments than command param names, we toss them out, because they may not be
     * part of the public API.
     * @param kind Either `required` or `optional`
     * @returns List of refls with names matching `commandParams`, throwing out any extra refls
     */
    const createNewRefls = (kind) => {
        const commandParams = cmd[`${kind}Params`];
        if (!commandParams?.length) {
            return [];
        }
        const paramCount = commandParams.length;
        const newParamRefls = [];
        for (let i = 0; i < paramCount; i++) {
            const pRefl = pRefls.shift();
            if (pRefl) {
                // if there isn't one, the warning above will have been logged already
                const newPRefl = new typedoc_1.ParameterReflection(commandParams[i], typedoc_1.ReflectionKind.CallSignature, sig);
                lodash_1.default.assign(newPRefl, lodash_1.default.pick(pRefl, PARAMETER_REFLECTION_CLONE_FIELDS));
                // there doesn't seem to be a straightforward way to clone flags.
                newPRefl.flags = new typedoc_1.ReflectionFlags(...pRefl.flags);
                newPRefl.flags.setFlag(typedoc_1.ReflectionFlag.Optional, kind === 'optional');
                newParamRefls.push(newPRefl);
            }
        }
        return newParamRefls;
    };
    const newParamRefls = [...createNewRefls('required'), ...createNewRefls('optional')];
    if (!newParamRefls.length) {
        return [];
    }
    return newParamRefls;
});
/**
 * Rewrites a method's return value for documentation.
 *
 * Given a command having a method declaration, creates a clone of its call signature wherein the
 * return type is unwrapped from `Promise`.  In other words, if a method returns `Promise<T>`,
 * this changes the return type in the signature to `T`.
 *
 * Note that the return type of a command's method declaration should always be a `ReferenceType` having
 * name `Promise`.
 */
BaseCommandData.unwrapSignatureType = lodash_1.default.memoize((cmd) => {
    const callSig = BaseCommandData.findCallSignature(cmd);
    if (!callSig) {
        return;
    }
    if ((0, guards_1.isReferenceType)(callSig.type) && callSig.type.name === 'Promise') {
        const newCallSig = new typedoc_1.SignatureReflection(callSig.name, typedoc_1.ReflectionKind.CallSignature, cmd.methodRefl);
        lodash_1.default.assign(newCallSig, lodash_1.default.pick(callSig, SIGNATURE_REFLECTION_CLONE_FIELDS));
        // this is the actual unwrapping.  `Promise` only has a single type argument `T`,
        // so we can safely use the first one.
        newCallSig.type = callSig.type.typeArguments?.[0];
        if (!newCallSig.type) {
            cmd.log.warn('(%s) No type arg T found for return type Promise<T> in %s; this is a bug', cmd.parentRefl.name, cmd.methodRefl.name);
            return;
        }
        return newCallSig;
    }
});
/**
 * Represents a generic WD or Appium-specific endpoint
 */
class CommandData extends BaseCommandData {
    constructor(log, command, httpMethod, route, opts = {}) {
        super(log, command, opts);
        this.httpMethod = httpMethod;
        this.route = route;
    }
    /**
     * Creates a **shallow** clone of this instance.
     *
     * Keeps props {@linkcode BaseCommandData.command command},
     * {@linkcode CommandData.httpMethod httpMethod} and
     * {@linkcode CommandData.route route}, then applies any other options.
     * @param opts Options to apply. _Note:_ you probably want to provide a new `parentRefl`.
     * @returns Cloned instance
     */
    clone(opts = {}) {
        return new CommandData(this.log, this.command, this.httpMethod, this.route, { ...this, ...opts });
    }
}
exports.CommandData = CommandData;
/**
 * Represents an "execute command" ("execute method")
 *
 * Each will have a unique `script` property which is provided as the script to run via the
 * `execute` WD endpoint.
 *
 * All of these share the same `execute` route, so it is omitted from this interface.
 */
class ExecMethodData extends BaseCommandData {
    constructor(log, command, script, opts = {}) {
        super(log, command, opts);
        this.script = script;
        if (!this.methodRefl) {
            this.log.verbose(`No reflection for script ${script}`);
        }
    }
    /**
     * Creates a **shallow** clone of this instance.
     *
     * Keeps props {@linkcode BaseCommandData.command command}, {@linkcode ExecMethod.script script},
     * then applies any other options.
     * @param opts Options to apply
     * @returns Cloned instance
     */
    clone(opts) {
        return new ExecMethodData(this.log, this.command, this.script, { ...this, ...opts });
    }
}
exports.ExecMethodData = ExecMethodData;
//# sourceMappingURL=command-data.js.map