"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _CommandReflection_log;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandReflection = exports.HTTP_METHOD_EXECUTE = exports.NAME_EXECUTE_ROUTE = void 0;
const pluralize_1 = __importDefault(require("pluralize"));
const typedoc_1 = require("typedoc");
const converter_1 = require("../../converter");
const guards_1 = require("../../guards");
const kind_1 = require("./kind");
/**
 * Execute Methods all have the same route.
 */
exports.NAME_EXECUTE_ROUTE = '/session/:sessionId/execute';
/**
 * Execute methods all have the same HTTP method.
 */
exports.HTTP_METHOD_EXECUTE = 'POST';
/**
 * A reflection containing data about a single command or execute method.
 *
 * Methods may be invoked directly by Handlebars templates.
 */
class CommandReflection extends typedoc_1.DeclarationReflection {
    /**
     * Sets props depending on type of `data`
     * @param data Command or execute method data
     * @param parent Always a {@linkcode ExtensionReflection}
     * @param route Route, if not an execute method
     */
    constructor(data, parent, log, route) {
        let name;
        let kind;
        let script;
        let httpMethod;
        // common data
        const { requiredParams, optionalParams, comment, methodRefl: refl, commentSource, parameters, signature, command, } = data;
        // kind-specific data
        if ((0, guards_1.isExecMethodData)(data)) {
            script = name = data.script;
            kind = kind_1.AppiumPluginReflectionKind.ExecuteMethod;
            route = exports.NAME_EXECUTE_ROUTE;
            httpMethod = exports.HTTP_METHOD_EXECUTE;
        }
        else {
            if (!route) {
                throw new TypeError('"route" arg is required for a non-execute-method command');
            }
            name = command;
            kind = kind_1.AppiumPluginReflectionKind.Command;
            httpMethod = data.httpMethod;
        }
        super(name, kind, parent);
        this.data = data;
        _CommandReflection_log.set(this, void 0);
        __classPrivateFieldSet(this, _CommandReflection_log, log, "f");
        this.route = route;
        this.httpMethod = httpMethod;
        this.requiredParams = requiredParams ?? [];
        this.optionalParams = optionalParams ?? [];
        this.script = script;
        this.refl = refl;
        this.commentSource = commentSource;
        this.parameters = parameters;
        this.signature = signature;
        const extractedExamples = (0, converter_1.extractExamples)(comment);
        if (extractedExamples?.examples?.length) {
            __classPrivateFieldGet(this, _CommandReflection_log, "f").verbose('Extracted %s from comment in %s', (0, pluralize_1.default)('example', extractedExamples.examples.length, true), this.name);
        }
        this.examples = extractedExamples?.examples;
        this.comment = extractedExamples?.comment;
    }
    /**
     * If `true`, this command has required parameters
     *
     * Used by templates
     */
    get hasRequiredParams() {
        return Boolean(this.requiredParams.length);
    }
    /**
     * If `true`, this command has optional parameters
     *
     * Used by templates
     */
    get hasOptionalParams() {
        return Boolean(this.optionalParams.length);
    }
    /**
     * If `true`, this command contains data about an execute method
     *
     * Used by templates
     */
    get isExecuteMethod() {
        return this.kindOf(kind_1.AppiumPluginReflectionKind.ExecuteMethod);
    }
    /**
     * If `true`, this command contains one or more examples
     *
     * Used by templates
     */
    get hasExample() {
        return Boolean(this.examples?.length);
    }
}
exports.CommandReflection = CommandReflection;
_CommandReflection_log = new WeakMap();
//# sourceMappingURL=command.js.map