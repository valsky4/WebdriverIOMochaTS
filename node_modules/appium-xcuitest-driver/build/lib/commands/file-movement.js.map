{"version":3,"file":"file-movement.js","names":["_lodash","_interopRequireDefault","require","_support","_path","_logger","_appiumIosDevice","_iosFsHelpers","_driver","_utils","CONTAINER_PATH_MARKER","CONTAINER_PATH_PATTERN","RegExp","CONTAINER_TYPE_SEPARATOR","CONTAINER_DOCUMENTS_PATH","OBJECT_NOT_FOUND_ERROR_MESSAGE","commands","exports","verifyIsSubPath","originalPath","root","normalizedRoot","path","normalize","normalizedPath","dirname","startsWith","Error","createAfcClient","udid","bundleId","containerType","services","startAfcService","service","startHouseArrestService","isDocumentsContainer","vendDocuments","vendContainer","_","toLower","createService","remotePath","test","pathInContainer","parseContainerPath","relativePath","join","containerRootSupplier","match","exec","typeSeparatorPos","indexOf","length","substring","log","debug","isNil","containerRoot","isFunction","posix","resolve","pushFileToSimulator","device","base64Data","buffer","Buffer","from","dstPath","appBundle","simctl","getAppContainer","info","fs","exists","mkdirp","writeFile","dstFolder","tempDir","openDir","basename","addMedia","rimraf","pushFileToRealDevice","pushFile","e","stack","message","close","deleteFileOrFolder","isSimulator","deleteFromSimulator","deleteFromRealDevice","pullFromSimulator","isFile","pathOnServer","simRoot","getDir","errorAndThrow","util","toInMemoryBase64","zip","toInMemoryZip","encodeToBase64","toString","pullFromRealDevice","fileInfo","getFileInfo","isDirectory","pullFile","pullFolder","errors","InvalidArgumentError","deleteDirectory","includes","endsWith","isArray","opts","mobilePushFile","payload","requireArgs","mobilePullFile","mobileDeleteFolder","mobileDeleteFile","mobilePullFolder","_default","default"],"sources":["../../../lib/commands/file-movement.js"],"sourcesContent":["import _ from 'lodash';\nimport { fs, tempDir, mkdirp, zip, util } from 'appium/support';\nimport path from 'path';\nimport log from '../logger';\nimport { services } from 'appium-ios-device';\nimport { pullFile, pullFolder, pushFile } from '../ios-fs-helpers';\nimport { errors } from 'appium/driver';\nimport { requireArgs } from '../utils';\n\nconst CONTAINER_PATH_MARKER = '@';\n// https://regex101.com/r/PLdB0G/2\nconst CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);\nconst CONTAINER_TYPE_SEPARATOR = ':';\nconst CONTAINER_DOCUMENTS_PATH = 'Documents';\nconst OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';\n\nconst commands = {};\n\nfunction verifyIsSubPath (originalPath, root) {\n  const normalizedRoot = path.normalize(root);\n  const normalizedPath = path.normalize(path.dirname(originalPath));\n  // If originalPath is root, `/`, originalPath should equal to normalizedRoot\n  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {\n    throw new Error(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);\n  }\n}\n\nasync function createAfcClient (udid, bundleId, containerType) {\n  if (!bundleId) {\n    return await services.startAfcService(udid);\n  }\n  const service = await services.startHouseArrestService(udid);\n  return isDocumentsContainer(containerType)\n    ? await service.vendDocuments(bundleId)\n    : await service.vendContainer(bundleId);\n}\n\nfunction isDocumentsContainer (containerType) {\n  return _.toLower(containerType) === _.toLower(CONTAINER_DOCUMENTS_PATH);\n}\n\nasync function createService (udid, remotePath) {\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer, containerType} = await parseContainerPath(remotePath);\n    const service = await createAfcClient(udid, bundleId, containerType);\n    const relativePath = isDocumentsContainer(containerType)\n      ? path.join(CONTAINER_DOCUMENTS_PATH, pathInContainer)\n      : pathInContainer;\n    return {service, relativePath};\n  } else {\n    const service = await createAfcClient(udid);\n    return {service, relativePath: remotePath};\n  }\n}\n\n/**\n * @typedef {Object} ContainerObject\n *\n * @property {string} bundleId - The parsed bundle identifier\n * @property {string} pathInContainer - The absolute full path of the item on the local file system\n * @property {?string} containerType - The container type\n */\n\n/**\n * Parses the actual path and the bundle identifier from the given path string\n *\n * @param {string} remotePath - The given path string. The string should\n * match `CONTAINER_PATH_PATTERN` regexp, otherwise an error is going\n * to be thrown. A valid string example: `@bundle.identifier:container_type/relative_path_in_container`\n * @param {Function|string} containerRootSupplier - Either a string, that contains\n * full path to the mount root for real devices or a function, which accepts two parameters\n * (bundle identifier and optional container type) and returns full path to container\n * root folder on the local file system, for Simulator\n * @returns {ContainerObject}\n */\nasync function parseContainerPath (remotePath, containerRootSupplier) {\n  const match = CONTAINER_PATH_PATTERN.exec(remotePath);\n  if (!match) {\n    throw new Error(`It is expected that package identifier ` +\n      `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` +\n      `relative path with a single slash. '${remotePath}' is given instead`);\n  }\n  let [, bundleId, relativePath] = match;\n  let containerType = null;\n  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);\n  // We only consider container type exists if its length is greater than zero\n  // not counting the colon\n  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {\n    containerType = bundleId.substring(typeSeparatorPos + 1);\n    log.debug(`Parsed container type: ${containerType}`);\n    bundleId = bundleId.substring(0, typeSeparatorPos);\n  }\n  if (_.isNil(containerRootSupplier)) {\n    const pathInContainer = relativePath;\n    return { bundleId, pathInContainer, containerType };\n  }\n  const containerRoot = _.isFunction(containerRootSupplier)\n    ? await containerRootSupplier(bundleId, containerType)\n    : containerRootSupplier;\n  const pathInContainer = path.posix.resolve(containerRoot, relativePath);\n  verifyIsSubPath(pathInContainer, containerRoot);\n  return {bundleId, pathInContainer, containerType};\n}\n\n/**\n * Save the given base64 data chunk as a binary file on the Simulator under test.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The remote path on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be uploaded to the corresponding\n *                              application container instead of the default media folder, for example\n *                              '@com.myapp.bla:data/RelativePathInContainer/111.png'. The '@' character at the\n *                              beginning of the argument is mandatory in such case. The colon at the end of bundle identifier\n *                              is optional and is used to distinguish the container type.\n *                              Possible values there are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default value is 'app'.\n *                              The relative folder path is ignored if the file is going to be uploaded\n *                              to the default media folder and only the file name is considered important.\n * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.\n */\nasync function pushFileToSimulator (device, remotePath, base64Data) {\n  const buffer = Buffer.from(base64Data, 'base64');\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `Will put the data into '${dstPath}'`);\n    if (!await fs.exists(path.dirname(dstPath))) {\n      log.debug(`The destination folder '${path.dirname(dstPath)}' does not exist. Creating...`);\n      await mkdirp(path.dirname(dstPath));\n    }\n    await fs.writeFile(dstPath, buffer);\n    return;\n  }\n  const dstFolder = await tempDir.openDir();\n  const dstPath = path.resolve(dstFolder, path.basename(remotePath));\n  try {\n    await fs.writeFile(dstPath, buffer);\n    await device.simctl.addMedia(dstPath);\n  } finally {\n    await fs.rimraf(dstFolder);\n  }\n}\n\n/**\n * Save the given base64 data chunk as a binary file on the device under test.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The remote path on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be uploaded to the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   Base64 encoded `111.png` will be pushed into `On My iPhone/<app name>/111.png`\n *                                   as base64 decoded data.\n * @param {string} base64Data - Base-64 encoded content of the file to be uploaded.\n */\nasync function pushFileToRealDevice (device, remotePath, base64Data) {\n  const {service, relativePath} = await createService(device.udid, remotePath);\n  try {\n    await pushFile(service, relativePath, base64Data);\n  } catch (e) {\n    log.debug(e.stack);\n    throw new Error(`Could not push the file to '${remotePath}'.  Original error: ${e.message}`);\n  } finally {\n    service.close();\n  }\n}\n\nasync function deleteFileOrFolder (device, remotePath, isSimulator) {\n  return isSimulator\n    ? await deleteFromSimulator(device, remotePath)\n    : await deleteFromRealDevice(device, remotePath);\n}\n\n/**\n * Get the content of given file or folder from iOS Simulator and return it as base-64 encoded string.\n * Folder content is recursively packed into a zip archive.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to a file or a folder, which exists in the corresponding application\n *                              container on Simulator. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              Possible container types are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default type is 'app'.\n * @param {boolean} isFile - Whether the destination item is a file or a folder\n * @returns {string} Base-64 encoded content of the file.\n */\nasync function pullFromSimulator (device, remotePath, isFile) {\n  let pathOnServer;\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `Will get the data from '${dstPath}'`);\n    pathOnServer = dstPath;\n  } else {\n    const simRoot = device.getDir();\n    pathOnServer = path.posix.join(simRoot, remotePath);\n    verifyIsSubPath(pathOnServer, simRoot);\n    log.info(`Got the full item path: ${pathOnServer}`);\n  }\n  if (!await fs.exists(pathOnServer)) {\n    log.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);\n  }\n  const buffer = isFile\n    ? await util.toInMemoryBase64(pathOnServer)\n    : await zip.toInMemoryZip(pathOnServer, {encodeToBase64: true});\n  return buffer.toString();\n}\n\n/**\n * Get the content of given file or folder from the real device under test and return it as base-64 encoded string.\n * Folder content is recursively packed into a zip archive.\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to an existing remote file on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be downloaded from the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   `On My iPhone/<app name>/111.png` wil be pulled into the mounted host machine\n *                                   and Appium returns the data as base64-encoded string to client.\n *                                   `@com.myapp.bla:documents/` means `On My iPhone/<app name>`.\n * @param {boolean} isFile - Whether the destination item is a file or a folder\n * @return {string} Base-64 encoded content of the remote file\n */\nasync function pullFromRealDevice (device, remotePath, isFile) {\n  const {service, relativePath} = await createService(device.udid, remotePath);\n  try {\n    const fileInfo = await service.getFileInfo(relativePath);\n    if (isFile && fileInfo.isDirectory()) {\n      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);\n    }\n    if (!isFile && !fileInfo.isDirectory()) {\n      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);\n    }\n\n    return fileInfo.isFile()\n      ? (await pullFile(service, relativePath)).toString('base64')\n      : (await pullFolder(service, relativePath)).toString();\n  } finally {\n    service.close();\n  }\n}\n\n/**\n * Remove the file or folder from the device\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to a file or a folder, which exists in the corresponding application\n *                              container on Simulator. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              Possible container types are 'app', 'data', 'groups', '<A specific App Group container>'.\n *                              The default type is 'app'.\n */\nasync function deleteFromSimulator (device, remotePath) {\n  let pathOnServer;\n  if (CONTAINER_PATH_PATTERN.test(remotePath)) {\n    const {bundleId, pathInContainer: dstPath} = await parseContainerPath(remotePath,\n      async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));\n    log.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` +\n      `'${dstPath}' will be deleted`);\n    pathOnServer = dstPath;\n  } else {\n    const simRoot = device.getDir();\n    pathOnServer = path.posix.join(simRoot, remotePath);\n    verifyIsSubPath(pathOnServer, simRoot);\n    log.info(`Got the full path: ${pathOnServer}`);\n  }\n  if (!await fs.exists(pathOnServer)) {\n    throw new errors.InvalidArgumentError(`The remote path at '${pathOnServer}' does not exist`);\n  }\n  await fs.rimraf(pathOnServer);\n}\n\n/**\n * Remove the file or folder from the device\n *\n * @param {Object} device - The device object, which represents the device under test.\n *                          This object is expected to have the `udid` property containing the\n *                          valid device ID.\n * @param {string} remotePath - The path to an existing remote file on the device. This variable can be prefixed with\n *                              bundle id, so then the file will be downloaded from the corresponding\n *                              application container instead of the default media folder. Use\n *                              @<app_bundle_id>:<optional_container_type>/<path_to_the_file_or_folder_inside_container>\n *                              format to pull a file or a folder from an application container of the given type.\n *                              The only supported container type is 'documents'. If the container type is not set\n *                              explicitly for a bundle id, then the default application container is going to be mounted\n *                              (aka --container ifuse argument)\n *                              e.g. If `@com.myapp.bla:documents/111.png` is provided,\n *                                   `On My iPhone/<app name>` in Files app will be mounted in the host machine.\n *                                   `On My iPhone/<app name>/111.png` wil be pulled into the mounted host machine\n *                                   and Appium returns the data as base64-encoded string to client.\n *                                   `@com.myapp.bla:documents/` means `On My iPhone/<app name>`.\n */\nasync function deleteFromRealDevice (device, remotePath) {\n  const { service, relativePath } = await createService(device.udid, remotePath);\n  try {\n    await service.deleteDirectory(relativePath);\n  } catch (e) {\n    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {\n      throw new Error(`Path '${remotePath}' does not exist on the device`);\n    }\n    throw e;\n  } finally {\n    service.close();\n  }\n}\n\n/**\n * Pushes the given data to a file on the remote device\n *\n * @param {string} remotePath The full path to the remote file or\n * a file inside a package bundle. Check the documentation on\n * `pushFileToRealDevice` and `pushFileToSimulator` for more information\n * on acceptable values.\n * @param {string} base64Data Base64 encoded data to be written to the\n * remote file. The remote file will be silently overridden if it already exists.\n * @throws {Error} If there was an error while pushing the data\n */\ncommands.pushFile = async function pushFile (remotePath, base64Data) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  if (_.isArray(base64Data)) {\n    // some clients (ahem) java, send a byte array encoding utf8 characters\n    // instead of a string, which would be infinitely better!\n    base64Data = Buffer.from(base64Data).toString('utf8');\n  }\n  return this.isSimulator()\n    ? await pushFileToSimulator(this.opts.device, remotePath, base64Data)\n    : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);\n};\n\n/**\n * @typedef {Object} PushFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside an app bundle.\n * @property {string} payload Base64-encoded content of the file to be pushed.\n */\n\n/**\n * Pushes the given data to a file on the remote device.\n *\n * @param {PushFileOptions} opts\n */\ncommands.mobilePushFile = async function mobilePushFile (opts = {}) {\n  const { remotePath, payload } = requireArgs(['remotePath', 'payload'], opts);\n  return await this.pushFile(remotePath, payload);\n};\n\n/**\n * Pulls a remote file from the device.\n *\n * @param {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n * @returns {string} Base64 encoded content of the pulled file\n * @throws {Error} If the pull operation failed\n */\ncommands.pullFile = async function pullFile (remotePath) {\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  return this.isSimulator()\n    ? await pullFromSimulator(this.opts.device, remotePath, true)\n    : await pullFromRealDevice(this.opts.device, remotePath, true);\n};\n\n/**\n * @typedef {Object} PullFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Pulls a remote file from the device.\n *\n * @param {PullFileOptions} opts\n * @returns {string} The same as in `pullFile`\n */\ncommands.mobilePullFile = async function mobilePullFile (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFile(remotePath);\n};\n\n/**\n * @typedef {Object} DeleteFolderOptions\n * @property {string} remotePath The full path to the remote folder\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Delete a remote folder from the device.\n *\n * @param {DeleteFolderOptions} opts\n */\ncommands.mobileDeleteFolder = async function mobileDeleteFolder (opts = {}) {\n  let { remotePath } = requireArgs('remotePath', opts);\n  if (!remotePath.endsWith('/')) {\n    remotePath = `${remotePath}/`;\n  }\n  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());\n};\n\n/**\n * @typedef {Object} DeleteFileOptions\n * @property {string} remotePath The full path to the remote file\n * or a specially formatted path, which points to an item inside app bundle.\n * See the documentation for `pullFromRealDevice` and `pullFromSimulator`\n * to get more information on acceptable values.\n */\n\n/**\n * Delete a remote file from the device.\n *\n * @param {DeleteFileOptions} opts\n */\ncommands.mobileDeleteFile = async function mobileDeleteFile (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  if (remotePath.endsWith('/')) {\n    throw new errors.InvalidArgumentError(`It is expected that remote path points to a file and not to a folder. ` +\n      `'${remotePath}' is given instead`);\n  }\n  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());\n};\n\n/**\n * Pulls the whole folder from the remote device\n *\n * @param {string} remotePath The full path to a folder on the\n * remote device or a folder inside an application bundle\n * @returns {string} Zipped and base64-encoded content of the folder\n * @throws {Error} If there was a failure while getting the folder content\n */\ncommands.pullFolder = async function pullFolder (remotePath) {\n  if (!remotePath.endsWith('/')) {\n    remotePath = `${remotePath}/`;\n  }\n  return this.isSimulator()\n    ? await pullFromSimulator(this.opts.device, remotePath, false)\n    : await pullFromRealDevice(this.opts.device, remotePath, false);\n};\n\n/**\n * @typedef {Object} PullFolderOptions\n * @property {string} remotePath The full path to the remote folder.\n */\n\n/**\n * Pulls the whole folder from the device under test.\n *\n * @param {PullFolderOptions} opts\n * @returns {string} The same as `pullFolder`\n */\ncommands.mobilePullFolder = async function mobilePullFolder (opts = {}) {\n  const { remotePath } = requireArgs('remotePath', opts);\n  return await this.pullFolder(remotePath);\n};\n\nexport { commands, /* for testing */ parseContainerPath };\nexport default commands;\n"],"mappings":"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"}