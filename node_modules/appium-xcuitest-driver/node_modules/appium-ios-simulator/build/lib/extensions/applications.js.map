{"version":3,"file":"applications.js","names":["extensions","installApp","app","simctl","getUserInstalledBundleIdsByBundleName","bundleName","appsRoot","path","resolve","getDir","infoPlists","fs","glob","cwd","nosort","strict","absolute","_","isEmpty","bundleInfoPromises","infoPlist","push","plist","parsePlistFile","ign","bundleInfos","B","all","filter","isPlainObject","bundleIds","CFBundleName","map","CFBundleIdentifier","log","debug","util","pluralize","length","JSON","stringify","isAppInstalled","bundleId","appContainer","getAppContainer","endsWith","err","info","appInfo","includes","e","removeApp","launchApp","opts","wait","timeoutMs","waitForCondition","isAppRunning","waitMs","intervalMs","Error","terminateApp","ps","some","name","scrubApp","appDataRoot","appFiles","nodir","p","rimraf"],"sources":["../../../lib/extensions/applications.js"],"sourcesContent":["import _ from 'lodash';\nimport path from 'path';\nimport { fs, plist, util } from '@appium/support';\nimport log from '../logger';\nimport B from 'bluebird';\nimport { waitForCondition } from 'asyncbox';\n\nconst extensions = {};\n\n/**\n * Install valid .app package on Simulator.\n *\n * @param {string} app - The path to the .app package.\n */\nextensions.installApp = async function installApp (app) {\n  return await this.simctl.installApp(app);\n};\n\n/**\n * Returns user installed bundle ids which has 'bundleName' in their Info.Plist as 'CFBundleName'\n *\n * @param {string} bundleName - The bundle name of the application to be checked.\n * @return {array<string>} - The list of bundle ids which have 'bundleName'\n */\nextensions.getUserInstalledBundleIdsByBundleName = async function getUserInstalledBundleIdsByBundleName (bundleName) {\n  const appsRoot = path.resolve(this.getDir(), 'Containers', 'Bundle', 'Application');\n  // glob all Info.plist from simdir/data/Containers/Bundle/Application\n  const infoPlists = await fs.glob('*/*.app/Info.plist', {\n    cwd: appsRoot,\n    nosort: true,\n    strict: false,\n    absolute: true,\n  });\n  if (_.isEmpty(infoPlists)) {\n    return [];\n  }\n\n  const bundleInfoPromises = [];\n  for (const infoPlist of infoPlists) {\n    bundleInfoPromises.push((async () => {\n      try {\n        return await plist.parsePlistFile(infoPlist);\n      } catch (ign) {}\n    })());\n  }\n  const bundleInfos = (await B.all(bundleInfoPromises)).filter(_.isPlainObject);\n  const bundleIds = bundleInfos\n    .filter(({ CFBundleName }) => CFBundleName === bundleName)\n    .map(({ CFBundleIdentifier }) => CFBundleIdentifier);\n  if (_.isEmpty(bundleIds)) {\n    return [];\n  }\n\n  log.debug(\n    `The simulator has ${util.pluralize('bundle', bundleIds.length, true)} which ` +\n    `have '${bundleName}' as their 'CFBundleName': ${JSON.stringify(bundleIds)}`\n  );\n  return bundleIds;\n};\n\n/**\n * Verify whether the particular application is installed on Simulator.\n *\n * @param {string} bundleId - The bundle id of the application to be checked.\n * @return {boolean} True if the given application is installed.\n */\nextensions.isAppInstalled = async function isAppInstalled (bundleId) {\n  try {\n    const appContainer = await this.simctl.getAppContainer(bundleId);\n    return appContainer.endsWith('.app');\n  } catch (err) {\n    // get_app_container subcommand fails for system applications,\n    // so we try the hidden appinfo subcommand, which prints correct info for\n    // system/hidden apps\n    try {\n      const info = await this.simctl.appInfo(bundleId);\n      return info.includes('ApplicationType');\n    } catch (e) {\n      return false;\n    }\n  }\n};\n\n/**\n * Uninstall the given application from the current Simulator.\n *\n * @param {string} bundleId - The buindle ID of the application to be removed.\n */\nextensions.removeApp = async function removeApp (bundleId) {\n  await this.simctl.removeApp(bundleId);\n};\n\n/**\n * @typedef {Object} LaunchAppOpts\n * @property {boolean} wait [false] Whether to wait until the app has fully started and\n * is present in processes list\n * @property {number} timeoutMs [10000] The number of milliseconds to wait until\n * the app is fully started. Only applicatble if `wait` is true.\n */\n\n/**\n * Starts the given application on Simulator\n *\n * @param {string} bundleId - The buindle ID of the application to be launched\n * @param {LaunchAppOpts} opts\n */\nextensions.launchApp = async function launchApp (bundleId, opts = {}) {\n  await this.simctl.launchApp(bundleId);\n  const {\n    wait = false,\n    timeoutMs = 10000,\n  } = opts;\n  if (!wait) {\n    return;\n  }\n\n  try {\n    await waitForCondition(async () => await this.isAppRunning(bundleId), {\n      waitMs: timeoutMs,\n      intervalMs: 300\n    });\n  } catch (e) {\n    throw new Error(`App '${bundleId}' is not runnning after ${timeoutMs}ms timeout.`);\n  }\n};\n\n/**\n * Stops the given application on  Simulator.\n *\n * @param {string} bundleId - The buindle ID of the application to be stopped\n */\nextensions.terminateApp = async function terminateApp (bundleId) {\n  await this.simctl.terminateApp(bundleId);\n};\n\n/**\n * Check if app with the given identifier is running.\n *\n * @param {string} bundleId - The buindle ID of the application to be checked.\n */\nextensions.isAppRunning = async function isAppRunning (bundleId) {\n  return (await this.ps()).some(({name}) => name === bundleId);\n};\n\n/**\n * Scrub (delete the preferences and changed files) the particular application on Simulator.\n * The app will be terminated automatically if it is running.\n *\n * @param {string} bundleId - Bundle identifier of the application.\n * @throws {Error} if the given app is not installed.\n */\nextensions.scrubApp = async function scrubApp (bundleId) {\n  const appDataRoot = await this.simctl.getAppContainer(bundleId, 'data');\n  const appFiles = await fs.glob('**/*', {\n    cwd: appDataRoot,\n    nosort: true,\n    strict: false,\n    nodir: true,\n    absolute: true,\n  });\n  log.info(`Found ${appFiles.length} ${bundleId} app ${util.pluralize('file', appFiles.length, false)} to scrub`);\n  if (_.isEmpty(appFiles)) {\n    return;\n  }\n\n  try {\n    await this.terminateApp(bundleId);\n  } catch (ign) {}\n  await B.all(appFiles.map((p) => fs.rimraf(p)));\n};\n\nexport default extensions;\n"],"mappings":"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"}