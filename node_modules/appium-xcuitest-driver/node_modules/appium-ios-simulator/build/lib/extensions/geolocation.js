"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("source-map-support/register");
var _lodash = _interopRequireDefault(require("lodash"));
var _support = require("@appium/support");
var _logger = _interopRequireDefault(require("../logger"));
var _teen_process = require("teen_process");
const LYFT_SET_LOCATION = 'set-simulator-location';
const DECIMAL_SEPARATOR_SCRIPT = `
use framework "Foundation"
use framework "AppKit"
use scripting additions

set theFormatter to current application's NSNumberFormatter's new()
set result to theFormatter's decimalSeparator()
log result as string
`;
async function setLocationWithLyft(udid, latitude, longitude) {
  try {
    await _support.fs.which(LYFT_SET_LOCATION);
  } catch (e) {
    throw new Error(`'${LYFT_SET_LOCATION}' binary has not been found in your PATH. ` + 'Please install it as "brew install lyft/formulae/set-simulator-location" by brew or ' + 'read https://github.com/MobileNativeFoundation/set-simulator-location to set ' + 'the binary by manual to be able to set geolocation by the library.');
  }
  try {
    await (0, _teen_process.exec)(LYFT_SET_LOCATION, ['-c', latitude, longitude, '-u', udid]);
  } catch (e) {
    throw new Error(`Failed to set geolocation with '${LYFT_SET_LOCATION}'. ` + `Original error: ${e.stderr || e.message}`);
  }
}
async function setLocationWithIdb(idb, latitude, longitude) {
  if (!idb) {
    throw new Error('Failed to set geolocation with idb because it is not installed or the "launchWithIDB" capability was not set');
  }
  try {
    await idb.setLocation(latitude, longitude);
  } catch (e) {
    throw new Error(`Failed to set geolocation with idb. Original error: ${e.stderr || e.message}`);
  }
}
async function setLocationWithAppleScript(sim, latitude, longitude, menu = 'Debug') {
  const {
    stdout,
    stderr
  } = await (0, _teen_process.exec)('osascript', ['-e', DECIMAL_SEPARATOR_SCRIPT]);
  const decimalSeparator = _lodash.default.trim(stdout || stderr);
  const [latitudeStr, longitudeStr] = [latitude, longitude].map(coord => `${coord}`.replace(/[.,]/, decimalSeparator));
  const output = await sim.executeUIClientScript(`
    tell application "System Events"
      tell process "Simulator"
        set featureName to "Custom Location"
        set dstMenuItem to menu item (featureName & "â€¦") of menu 1 of menu item "Location" of menu 1 of menu bar item "${menu}" of menu bar 1
        click dstMenuItem
        delay 1
        set value of text field 1 of window featureName to "${latitudeStr}"
        delay 0.5
        set value of text field 2 of window featureName to "${longitudeStr}"
        delay 0.5
        click button "OK" of window featureName
        delay 0.5
        set isInvisible to (not (exists (window featureName)))
      end tell
    end tell
  `);
  _logger.default.debug(`Geolocation parameters dialog accepted: ${output}`);
  if (_lodash.default.trim(output) !== 'true') {
    throw new Error(`Failed to set geolocation with AppleScript. Original error: ${output}`);
  }
}
const extensions = {};
extensions.setGeolocation = async function setGeolocation(latitude, longitude) {
  const locationSetters = [async () => await setLocationWithLyft(this.udid, latitude, longitude), async () => await setLocationWithIdb(this.idb, latitude, longitude), async () => await setLocationWithAppleScript(this, latitude, longitude, this._locationMenu)];
  let lastError;
  for (const setter of locationSetters) {
    try {
      await setter();
      return true;
    } catch (e) {
      _logger.default.info(e.message);
      lastError = e;
    }
  }
  throw lastError;
};
var _default = extensions;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMWUZUX1NFVF9MT0NBVElPTiIsIkRFQ0lNQUxfU0VQQVJBVE9SX1NDUklQVCIsInNldExvY2F0aW9uV2l0aEx5ZnQiLCJ1ZGlkIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJmcyIsIndoaWNoIiwiZSIsIkVycm9yIiwiZXhlYyIsInN0ZGVyciIsIm1lc3NhZ2UiLCJzZXRMb2NhdGlvbldpdGhJZGIiLCJpZGIiLCJzZXRMb2NhdGlvbiIsInNldExvY2F0aW9uV2l0aEFwcGxlU2NyaXB0Iiwic2ltIiwibWVudSIsInN0ZG91dCIsImRlY2ltYWxTZXBhcmF0b3IiLCJfIiwidHJpbSIsImxhdGl0dWRlU3RyIiwibG9uZ2l0dWRlU3RyIiwibWFwIiwiY29vcmQiLCJyZXBsYWNlIiwib3V0cHV0IiwiZXhlY3V0ZVVJQ2xpZW50U2NyaXB0IiwibG9nIiwiZGVidWciLCJleHRlbnNpb25zIiwic2V0R2VvbG9jYXRpb24iLCJsb2NhdGlvblNldHRlcnMiLCJfbG9jYXRpb25NZW51IiwibGFzdEVycm9yIiwic2V0dGVyIiwiaW5mbyJdLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9leHRlbnNpb25zL2dlb2xvY2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmc30gZnJvbSAnQGFwcGl1bS9zdXBwb3J0JztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuXG5jb25zdCBMWUZUX1NFVF9MT0NBVElPTiA9ICdzZXQtc2ltdWxhdG9yLWxvY2F0aW9uJztcbmNvbnN0IERFQ0lNQUxfU0VQQVJBVE9SX1NDUklQVCA9IGBcbnVzZSBmcmFtZXdvcmsgXCJGb3VuZGF0aW9uXCJcbnVzZSBmcmFtZXdvcmsgXCJBcHBLaXRcIlxudXNlIHNjcmlwdGluZyBhZGRpdGlvbnNcblxuc2V0IHRoZUZvcm1hdHRlciB0byBjdXJyZW50IGFwcGxpY2F0aW9uJ3MgTlNOdW1iZXJGb3JtYXR0ZXIncyBuZXcoKVxuc2V0IHJlc3VsdCB0byB0aGVGb3JtYXR0ZXIncyBkZWNpbWFsU2VwYXJhdG9yKClcbmxvZyByZXN1bHQgYXMgc3RyaW5nXG5gO1xuXG4vKipcbiAqIFNldCBjdXN0b20gZ2VvbG9jYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIFNpbXVsYXRvciB1c2luZyBMWUZUX1NFVF9MT0NBVElPTi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWRpZCAtIFRoZSB1ZGlkIHRvIHNldCB0aGUgZ2l2ZW4gZ2VvbG9jYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbGF0aXR1ZGUgLSBUaGUgbGF0aXR1ZGUgdmFsdWUsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGVudGVyZWRcbiAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMzksMDAwNicuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgdmFsdWUsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGVudGVyZWRcbiAqICAgaW50byB0aGUgY29ycmVzcG9uZGluZyBlZGl0IGZpZWxkLCBmb3IgZXhhbXBsZSAnMTksMDA2OCcuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgZmFpbGVkIHRvIHNldCB0aGUgbG9jYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0TG9jYXRpb25XaXRoTHlmdCAodWRpZCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKExZRlRfU0VUX0xPQ0FUSU9OKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7TFlGVF9TRVRfTE9DQVRJT059JyBiaW5hcnkgaGFzIG5vdCBiZWVuIGZvdW5kIGluIHlvdXIgUEFUSC4gYCArXG4gICAgICAnUGxlYXNlIGluc3RhbGwgaXQgYXMgXCJicmV3IGluc3RhbGwgbHlmdC9mb3JtdWxhZS9zZXQtc2ltdWxhdG9yLWxvY2F0aW9uXCIgYnkgYnJldyBvciAnICtcbiAgICAgICdyZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2JpbGVOYXRpdmVGb3VuZGF0aW9uL3NldC1zaW11bGF0b3ItbG9jYXRpb24gdG8gc2V0ICcgK1xuICAgICAgJ3RoZSBiaW5hcnkgYnkgbWFudWFsIHRvIGJlIGFibGUgdG8gc2V0IGdlb2xvY2F0aW9uIGJ5IHRoZSBsaWJyYXJ5LicpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKExZRlRfU0VUX0xPQ0FUSU9OLCBbXG4gICAgICAnLWMnLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLFxuICAgICAgJy11JywgdWRpZFxuICAgIF0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2V0IGdlb2xvY2F0aW9uIHdpdGggJyR7TFlGVF9TRVRfTE9DQVRJT059Jy4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5tZXNzYWdlfWApO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGN1c3RvbSBnZW9sb2NhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgZ2l2ZW4gU2ltdWxhdG9yIHVzaW5nIGlkYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaWRiIC0gVGhlIElEQiBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICczOSwwMDA2Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICcxOSwwMDY4Jy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBmYWlsZWQgdG8gc2V0IHRoZSBsb2NhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRMb2NhdGlvbldpdGhJZGIgKGlkYiwgbGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICBpZiAoIWlkYikge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNldCBnZW9sb2NhdGlvbiB3aXRoIGlkYiBiZWNhdXNlIGl0IGlzIG5vdCBpbnN0YWxsZWQgb3IgdGhlIFwibGF1bmNoV2l0aElEQlwiIGNhcGFiaWxpdHkgd2FzIG5vdCBzZXQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgaWRiLnNldExvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2V0IGdlb2xvY2F0aW9uIHdpdGggaWRiLiBPcmlnaW5hbCBlcnJvcjogJHtlLnN0ZGVyciB8fCBlLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgY3VzdG9tIGdlb2xvY2F0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBnaXZlbiBTaW11bGF0b3IgdXNpbmcgQXBwbGVTY3JpcHRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2ltIC0gVGhlIFNpbXVsYXRvclhjb2RlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICczOSwwMDA2Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbG9uZ2l0dWRlIC0gVGhlIGxvbmdpdHVkZSB2YWx1ZSwgd2hpY2ggaXMgZ29pbmcgdG8gYmUgZW50ZXJlZFxuICogICBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGVkaXQgZmllbGQsIGZvciBleGFtcGxlICcxOSwwMDY4Jy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWVudT1EZWJ1Z10gLSBUaGUgbWVudSBmaWVsZCBpbiB3aGljaCB0aGUgJ0xvY2F0aW9uJyBmZWF0dXJlIGlzIGZvdW5kXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgZmFpbGVkIHRvIHNldCB0aGUgbG9jYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0TG9jYXRpb25XaXRoQXBwbGVTY3JpcHQgKHNpbSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgbWVudSA9ICdEZWJ1ZycpIHtcbiAgLy8gTWFrZSBzdXJlIHN5c3RlbS13aWRlIGRlY2ltYWwgc2VwYXJhdG9yIGlzIHVzZWRcbiAgY29uc3Qge3N0ZG91dCwgc3RkZXJyfSA9IGF3YWl0IGV4ZWMoJ29zYXNjcmlwdCcsIFsnLWUnLCBERUNJTUFMX1NFUEFSQVRPUl9TQ1JJUFRdKTtcbiAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IF8udHJpbShzdGRvdXQgfHwgc3RkZXJyKTtcbiAgY29uc3QgW2xhdGl0dWRlU3RyLCBsb25naXR1ZGVTdHJdID0gW2xhdGl0dWRlLCBsb25naXR1ZGVdXG4gICAgLm1hcCgoY29vcmQpID0+IGAke2Nvb3JkfWAucmVwbGFjZSgvWy4sXS8sIGRlY2ltYWxTZXBhcmF0b3IpKTtcblxuICBjb25zdCBvdXRwdXQgPSBhd2FpdCBzaW0uZXhlY3V0ZVVJQ2xpZW50U2NyaXB0KGBcbiAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICB0ZWxsIHByb2Nlc3MgXCJTaW11bGF0b3JcIlxuICAgICAgICBzZXQgZmVhdHVyZU5hbWUgdG8gXCJDdXN0b20gTG9jYXRpb25cIlxuICAgICAgICBzZXQgZHN0TWVudUl0ZW0gdG8gbWVudSBpdGVtIChmZWF0dXJlTmFtZSAmIFwi4oCmXCIpIG9mIG1lbnUgMSBvZiBtZW51IGl0ZW0gXCJMb2NhdGlvblwiIG9mIG1lbnUgMSBvZiBtZW51IGJhciBpdGVtIFwiJHttZW51fVwiIG9mIG1lbnUgYmFyIDFcbiAgICAgICAgY2xpY2sgZHN0TWVudUl0ZW1cbiAgICAgICAgZGVsYXkgMVxuICAgICAgICBzZXQgdmFsdWUgb2YgdGV4dCBmaWVsZCAxIG9mIHdpbmRvdyBmZWF0dXJlTmFtZSB0byBcIiR7bGF0aXR1ZGVTdHJ9XCJcbiAgICAgICAgZGVsYXkgMC41XG4gICAgICAgIHNldCB2YWx1ZSBvZiB0ZXh0IGZpZWxkIDIgb2Ygd2luZG93IGZlYXR1cmVOYW1lIHRvIFwiJHtsb25naXR1ZGVTdHJ9XCJcbiAgICAgICAgZGVsYXkgMC41XG4gICAgICAgIGNsaWNrIGJ1dHRvbiBcIk9LXCIgb2Ygd2luZG93IGZlYXR1cmVOYW1lXG4gICAgICAgIGRlbGF5IDAuNVxuICAgICAgICBzZXQgaXNJbnZpc2libGUgdG8gKG5vdCAoZXhpc3RzICh3aW5kb3cgZmVhdHVyZU5hbWUpKSlcbiAgICAgIGVuZCB0ZWxsXG4gICAgZW5kIHRlbGxcbiAgYCk7XG4gIGxvZy5kZWJ1ZyhgR2VvbG9jYXRpb24gcGFyYW1ldGVycyBkaWFsb2cgYWNjZXB0ZWQ6ICR7b3V0cHV0fWApO1xuICBpZiAoXy50cmltKG91dHB1dCkgIT09ICd0cnVlJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNldCBnZW9sb2NhdGlvbiB3aXRoIEFwcGxlU2NyaXB0LiBPcmlnaW5hbCBlcnJvcjogJHtvdXRwdXR9YCk7XG4gIH1cbn1cblxuY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4vKipcbiAqIFNldCBjdXN0b20gZ2VvbG9jYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIGdpdmVuIFNpbXVsYXRvciB1c2luZyBBcHBsZVNjcmlwdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzM5LDAwMDYnLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsb25naXR1ZGUgLSBUaGUgbG9uZ2l0dWRlIHZhbHVlLCB3aGljaCBpcyBnb2luZyB0byBiZSBlbnRlcmVkXG4gKiAgIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgZWRpdCBmaWVsZCwgZm9yIGV4YW1wbGUgJzE5LDAwNjgnLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlcnMgaGF2ZSBjb3JyZWN0IGZvcm1hdCBhbmQgd2VyZSBzdWNjZXNzZnVsbHkgYWNjZXB0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHNldHRpbmcgdGhlIGxvY2F0aW9uXG4gKi9cbmV4dGVuc2lvbnMuc2V0R2VvbG9jYXRpb24gPSBhc3luYyBmdW5jdGlvbiBzZXRHZW9sb2NhdGlvbiAobGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICBjb25zdCBsb2NhdGlvblNldHRlcnMgPSBbXG4gICAgYXN5bmMgKCkgPT4gYXdhaXQgc2V0TG9jYXRpb25XaXRoTHlmdCh0aGlzLnVkaWQsIGxhdGl0dWRlLCBsb25naXR1ZGUpLFxuICAgIGFzeW5jICgpID0+IGF3YWl0IHNldExvY2F0aW9uV2l0aElkYih0aGlzLmlkYiwgbGF0aXR1ZGUsIGxvbmdpdHVkZSksXG4gICAgYXN5bmMgKCkgPT4gYXdhaXQgc2V0TG9jYXRpb25XaXRoQXBwbGVTY3JpcHQodGhpcywgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGhpcy5fbG9jYXRpb25NZW51KSxcbiAgXTtcblxuICBsZXQgbGFzdEVycm9yO1xuICBmb3IgKGNvbnN0IHNldHRlciBvZiBsb2NhdGlvblNldHRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2V0dGVyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuaW5mbyhlLm1lc3NhZ2UpO1xuICAgICAgbGFzdEVycm9yID0gZTtcbiAgICB9XG4g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