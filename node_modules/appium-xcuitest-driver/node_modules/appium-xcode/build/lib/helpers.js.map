{"version":3,"file":"helpers.js","names":["XCRUN_TIMEOUT","runXcrunCommand","args","timeout","exec","err","stderr","message","findAppPaths","bundleId","stdout","e","matchedPaths","_","trim","split","map","filter","Boolean","isEmpty","results","p","fs","exists","B","all","readXcodePlist","developerRoot","plistPath","path","resolve","plist","parsePlistFile"],"sources":["../../lib/helpers.js"],"sourcesContent":["import _ from 'lodash';\nimport B from 'bluebird';\nimport { exec } from 'teen_process';\nimport { fs, plist } from '@appium/support';\nimport path from 'path';\n\nexport const XCRUN_TIMEOUT = 15000;\n\n/**\n * Executes 'xcrun' command line utility\n *\n * @param {string[]} args xcrun arguments\n * @param {number} timeout [15000] The maximum number of milliseconds to wait until xcrun exists\n * @returns {Promise<import(\"teen_process\").ExecResult>} The result of xcrun execution\n * @throws {Error} If xcrun returned non-zero exit code or timed out\n */\nexport async function runXcrunCommand (args, timeout = XCRUN_TIMEOUT) {\n  try {\n    return await exec('xcrun', args, {timeout});\n  } catch (err) {\n    // the true error can be hidden within the stderr\n    if (err.stderr) {\n      err.message = `${err.message}: ${err.stderr}`;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Uses macOS Spotlight service to detect where the given app is installed\n *\n * @param {string} bundleId Bundle identifier of the target app\n * @returns {Promise<string[]>} Full paths to where the app with the given bundle id is present.\n */\nexport async function findAppPaths (bundleId) {\n  let stdout;\n  try {\n    ({stdout} = await exec('/usr/bin/mdfind', [\n      `kMDItemCFBundleIdentifier=${bundleId}`\n    ]));\n  } catch (e) {\n    return [];\n  }\n\n  const matchedPaths = _.trim(stdout)\n    .split('\\n')\n    .map(_.trim)\n    .filter(Boolean);\n  if (_.isEmpty(matchedPaths)) {\n    return [];\n  }\n  const results = matchedPaths.map((p) => (async () => {\n    if (await fs.exists(p)) {\n      return p;\n    }\n  })());\n  return (await B.all(results)).filter(Boolean);\n}\n\n/**\n * Finds and retrieves the content of the Xcode's Info.plist file\n *\n * @param {string} developerRoot Full path to the Contents/Developer folder under Xcode.app root\n * @returns {Promise<object>} All plist entries as an object or an empty object if no plist was found\n */\nexport async function readXcodePlist (developerRoot) {\n  const plistPath = path.resolve(developerRoot, '..', 'Info.plist');\n  return await fs.exists(plistPath)\n    ? await plist.parsePlistFile(plistPath)\n    : {};\n}\n"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEO,MAAMA,aAAa,GAAG,KAAK;AAAC;AAU5B,eAAeC,eAAe,CAAEC,IAAI,EAAEC,OAAO,GAAGH,aAAa,EAAE;EACpE,IAAI;IACF,OAAO,MAAM,IAAAI,kBAAI,EAAC,OAAO,EAAEF,IAAI,EAAE;MAACC;IAAO,CAAC,CAAC;EAC7C,CAAC,CAAC,OAAOE,GAAG,EAAE;IAEZ,IAAIA,GAAG,CAACC,MAAM,EAAE;MACdD,GAAG,CAACE,OAAO,GAAI,GAAEF,GAAG,CAACE,OAAQ,KAAIF,GAAG,CAACC,MAAO,EAAC;IAC/C;IAEA,MAAMD,GAAG;EACX;AACF;AAQO,eAAeG,YAAY,CAAEC,QAAQ,EAAE;EAC5C,IAAIC,MAAM;EACV,IAAI;IACF,CAAC;MAACA;IAAM,CAAC,GAAG,MAAM,IAAAN,kBAAI,EAAC,iBAAiB,EAAE,CACvC,6BAA4BK,QAAS,EAAC,CACxC,CAAC;EACJ,CAAC,CAAC,OAAOE,CAAC,EAAE;IACV,OAAO,EAAE;EACX;EAEA,MAAMC,YAAY,GAAGC,eAAC,CAACC,IAAI,CAACJ,MAAM,CAAC,CAChCK,KAAK,CAAC,IAAI,CAAC,CACXC,GAAG,CAACH,eAAC,CAACC,IAAI,CAAC,CACXG,MAAM,CAACC,OAAO,CAAC;EAClB,IAAIL,eAAC,CAACM,OAAO,CAACP,YAAY,CAAC,EAAE;IAC3B,OAAO,EAAE;EACX;EACA,MAAMQ,OAAO,GAAGR,YAAY,CAACI,GAAG,CAAEK,CAAC,IAAK,CAAC,YAAY;IACnD,IAAI,MAAMC,WAAE,CAACC,MAAM,CAACF,CAAC,CAAC,EAAE;MACtB,OAAOA,CAAC;IACV;EACF,CAAC,GAAG,CAAC;EACL,OAAO,CAAC,MAAMG,iBAAC,CAACC,GAAG,CAACL,OAAO,CAAC,EAAEH,MAAM,CAACC,OAAO,CAAC;AAC/C;AAQO,eAAeQ,cAAc,CAAEC,aAAa,EAAE;EACnD,MAAMC,SAAS,GAAGC,aAAI,CAACC,OAAO,CAACH,aAAa,EAAE,IAAI,EAAE,YAAY,CAAC;EACjE,OAAO,OAAML,WAAE,CAACC,MAAM,CAACK,SAAS,CAAC,IAC7B,MAAMG,cAAK,CAACC,cAAc,CAACJ,SAAS,CAAC,GACrC,CAAC,CAAC;AACR"}