"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClangVersion = getClangVersion;
exports.getMaxIOSSDK = void 0;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getMaxTVOSSDK = void 0;
exports.getMaxTVOSSDKWithoutRetry = getMaxTVOSSDKWithoutRetry;
exports.getPath = void 0;
exports.getPathFromDeveloperDir = getPathFromDeveloperDir;
exports.getPathFromXcodeSelect = getPathFromXcodeSelect;
exports.getVersion = getVersion;
require("source-map-support/register");
var _support = require("@appium/support");
var _path = _interopRequireDefault(require("path"));
var _asyncbox = require("asyncbox");
var _lodash = _interopRequireDefault(require("lodash"));
var _teen_process = require("teen_process");
var _semver = _interopRequireDefault(require("semver"));
var _helpers = require("./helpers");
const DEFAULT_NUMBER_OF_RETRIES = 2;
const XCODE_BUNDLE_ID = 'com.apple.dt.Xcode';
const log = _support.logger.getLogger('Xcode');
async function getPathFromXcodeSelect(timeout = _helpers.XCRUN_TIMEOUT) {
  const generateErrorMessage = async prefix => {
    const xcodePaths = await (0, _helpers.findAppPaths)(XCODE_BUNDLE_ID);
    if (_lodash.default.isEmpty(xcodePaths)) {
      return `${prefix}. Consider installing Xcode to address this issue.`;
    }
    const proposals = xcodePaths.map(p => `    sudo xcode-select -s "${_path.default.join(p, 'Contents', 'Developer')}"`);
    return `${prefix}. ` + `Consider running${proposals.length > 1 ? ' any of' : ''}:\n${'\n'.join(proposals)}\nto address this issue.`;
  };
  let stdout;
  try {
    ({
      stdout
    } = await (0, _teen_process.exec)('xcode-select', ['--print-path'], {
      timeout
    }));
  } catch (e) {
    log.errorAndThrow(`Cannot determine the path to Xcode by running 'xcode-select -p' command. ` + `Original error: ${e.stderr || e.message}`);
  }
  const developerRoot = stdout.replace(/\/$/, '').trim();
  if (!developerRoot) {
    log.errorAndThrow(await generateErrorMessage(`'xcode-select -p' returned an empty string`));
  }
  const {
    CFBundleIdentifier
  } = await (0, _helpers.readXcodePlist)(developerRoot);
  if (CFBundleIdentifier === XCODE_BUNDLE_ID) {
    return developerRoot;
  }
  log.errorAndThrow(await generateErrorMessage(`'${developerRoot}' is not a valid Xcode path`));
}
async function getPathFromDeveloperDir() {
  const developerRoot = process.env.DEVELOPER_DIR;
  const {
    CFBundleIdentifier
  } = await (0, _helpers.readXcodePlist)(developerRoot);
  if (CFBundleIdentifier === XCODE_BUNDLE_ID) {
    return developerRoot;
  }
  log.errorAndThrow(`The path to Xcode Developer dir '${developerRoot}' provided in DEVELOPER_DIR ` + `environment variable is not a valid path`);
}
const getPath = _lodash.default.memoize(function getPath(timeout = _helpers.XCRUN_TIMEOUT) {
  return process.env.DEVELOPER_DIR ? getPathFromDeveloperDir() : getPathFromXcodeSelect(timeout);
});
exports.getPath = getPath;
async function getVersionWithoutRetry(timeout = _helpers.XCRUN_TIMEOUT) {
  const developerPath = await getPath(timeout);
  const {
    CFBundleShortVersionString
  } = await (0, _helpers.readXcodePlist)(developerPath);
  return _semver.default.coerce(CFBundleShortVersionString);
}
const getVersionMemoized = _lodash.default.memoize(function getVersionMemoized(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = _helpers.XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});
async function getVersion(parse = false, retries = DEFAULT_NUMBER_OF_RETRIES, timeout = _helpers.XCRUN_TIMEOUT) {
  const version = await getVersionMemoized(retries, timeout);
  const versionString = version.patch > 0 ? version.version : `${version.major}.${version.minor}`;
  if (!parse) {
    return versionString;
  }
  return {
    versionString,
    versionFloat: parseFloat(versionString),
    major: version.major,
    minor: version.minor,
    patch: version.patch > 0 ? version.patch : undefined,
    toString() {
      return versionString;
    }
  };
}
async function getClangVersion() {
  try {
    await _support.fs.which('clang');
  } catch (e) {
    log.info('Cannot find clang executable on the local system. ' + 'Are Xcode Command Line Tools installed?');
    return null;
  }
  const {
    stdout
  } = await (0, _teen_process.exec)('clang', ['--version']);
  const match = /clang-([0-9.]+)/.exec(stdout);
  if (!match) {
    log.info(`Cannot parse clang version from ${stdout}`);
    return null;
  }
  return match[1];
}
async function getMaxIOSSDKWithoutRetry(timeout = _helpers.XCRUN_TIMEOUT) {
  const args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
  const {
    stdout
  } = await (0, _helpers.runXcrunCommand)(args, timeout);
  const sdkVersion = stdout.trim();
  const match = /\d.\d/.exec(stdout);
  if (!match) {
    throw new Error(`xcrun returned a non-numeric iOS SDK version: '${sdkVersion}'`);
  }
  return sdkVersion;
}
const getMaxIOSSDK = _lodash.default.memoize(function getMaxIOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = _helpers.XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
});
exports.getMaxIOSSDK = getMaxIOSSDK;
async function getMaxTVOSSDKWithoutRetry(timeout = _helpers.XCRUN_TIMEOUT) {
  const args = ['--sdk', 'appletvsimulator', '--show-sdk-version'];
  const {
    stdout
  } = await (0, _helpers.runXcrunCommand)(args, timeout);
  const sdkVersion = stdout.trim();
  if (isNaN(parseFloat(sdkVersion))) {
    throw new Error(`xcrun returned a non-numeric tvOS SDK version: '${sdkVersion}'`);
  }
  return sdkVersion;
}
const getMaxTVOSSDK = _lodash.default.memoize(function getMaxTVOSSDK(retries = DEFAULT_NUMBER_OF_RETRIES, timeout = _helpers.XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxTVOSSDKWithoutRetry, timeout);
});
exports.getMaxTVOSSDK = getMaxTVOSSDK;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTIiwiWENPREVfQlVORExFX0lEIiwibG9nIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZ2V0UGF0aEZyb21YY29kZVNlbGVjdCIsInRpbWVvdXQiLCJYQ1JVTl9USU1FT1VUIiwiZ2VuZXJhdGVFcnJvck1lc3NhZ2UiLCJwcmVmaXgiLCJ4Y29kZVBhdGhzIiwiZmluZEFwcFBhdGhzIiwiXyIsImlzRW1wdHkiLCJwcm9wb3NhbHMiLCJtYXAiLCJwIiwicGF0aCIsImpvaW4iLCJsZW5ndGgiLCJzdGRvdXQiLCJleGVjIiwiZSIsImVycm9yQW5kVGhyb3ciLCJzdGRlcnIiLCJtZXNzYWdlIiwiZGV2ZWxvcGVyUm9vdCIsInJlcGxhY2UiLCJ0cmltIiwiQ0ZCdW5kbGVJZGVudGlmaWVyIiwicmVhZFhjb2RlUGxpc3QiLCJnZXRQYXRoRnJvbURldmVsb3BlckRpciIsInByb2Nlc3MiLCJlbnYiLCJERVZFTE9QRVJfRElSIiwiZ2V0UGF0aCIsIm1lbW9pemUiLCJnZXRWZXJzaW9uV2l0aG91dFJldHJ5IiwiZGV2ZWxvcGVyUGF0aCIsIkNGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIiwic2VtdmVyIiwiY29lcmNlIiwiZ2V0VmVyc2lvbk1lbW9pemVkIiwicmV0cmllcyIsInJldHJ5IiwiZ2V0VmVyc2lvbiIsInBhcnNlIiwidmVyc2lvbiIsInZlcnNpb25TdHJpbmciLCJwYXRjaCIsIm1ham9yIiwibWlub3IiLCJ2ZXJzaW9uRmxvYXQiLCJwYXJzZUZsb2F0IiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJnZXRDbGFuZ1ZlcnNpb24iLCJmcyIsIndoaWNoIiwiaW5mbyIsIm1hdGNoIiwiZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5IiwiYXJncyIsInJ1blhjcnVuQ29tbWFuZCIsInNka1ZlcnNpb24iLCJFcnJvciIsImdldE1heElPU1NESyIsImdldE1heFRWT1NTREtXaXRob3V0UmV0cnkiLCJpc05hTiIsImdldE1heFRWT1NTREsiXSwic291cmNlcyI6WyIuLi8uLi9saWIveGNvZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnMsIGxvZ2dlciB9IGZyb20gJ0BhcHBpdW0vc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHtcbiAgcnVuWGNydW5Db21tYW5kLCBmaW5kQXBwUGF0aHMsIFhDUlVOX1RJTUVPVVQsIHJlYWRYY29kZVBsaXN0XG59IGZyb20gJy4vaGVscGVycyc7XG5cbmNvbnN0IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMgPSAyO1xuY29uc3QgWENPREVfQlVORExFX0lEID0gJ2NvbS5hcHBsZS5kdC5YY29kZSc7XG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1hjb2RlJyk7XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBmdWxsIHBhdGggdG8gWGNvZGUgRGV2ZWxvcGVyIHN1YmZvbGRlciB2aWEgeGNvZGUtc2VsZWN0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGhlIG1heGltdW0gdGltZW91dCBmb3IgeGNvZGUtc2VsZWN0IGV4ZWN1dGlvblxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gRnVsbCBwYXRoIHRvIFhjb2RlIERldmVsb3BlciBzdWJmb2xkZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBpcyBub3QgcG9zc2libGUgdG8gcmV0cmlldmUgYSBwcm9wZXIgcGF0aFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBnZW5lcmF0ZUVycm9yTWVzc2FnZSA9IGFzeW5jIChwcmVmaXgpID0+IHtcbiAgICBjb25zdCB4Y29kZVBhdGhzID0gYXdhaXQgZmluZEFwcFBhdGhzKFhDT0RFX0JVTkRMRV9JRCk7XG4gICAgaWYgKF8uaXNFbXB0eSh4Y29kZVBhdGhzKSkge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0uIENvbnNpZGVyIGluc3RhbGxpbmcgWGNvZGUgdG8gYWRkcmVzcyB0aGlzIGlzc3VlLmA7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcG9zYWxzID0geGNvZGVQYXRocy5tYXAoKHApID0+IGAgICAgc3VkbyB4Y29kZS1zZWxlY3QgLXMgXCIke3BhdGguam9pbihwLCAnQ29udGVudHMnLCAnRGV2ZWxvcGVyJyl9XCJgKTtcbiAgICByZXR1cm4gYCR7cHJlZml4fS4gYCArXG4gICAgICBgQ29uc2lkZXIgcnVubmluZyR7cHJvcG9zYWxzLmxlbmd0aCA+IDEgPyAnIGFueSBvZicgOiAnJ306XFxuJHsnXFxuJy5qb2luKHByb3Bvc2Fscyl9XFxudG8gYWRkcmVzcyB0aGlzIGlzc3VlLmA7XG4gIH07XG5cbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QnLCBbJy0tcHJpbnQtcGF0aCddLCB7dGltZW91dH0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDYW5ub3QgZGV0ZXJtaW5lIHRoZSBwYXRoIHRvIFhjb2RlIGJ5IHJ1bm5pbmcgJ3hjb2RlLXNlbGVjdCAtcCcgY29tbWFuZC4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5zdGRlcnIgfHwgZS5tZXNzYWdlfWApO1xuICB9XG4gIC8vIHRyaW0gYW5kIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICBjb25zdCBkZXZlbG9wZXJSb290ID0gc3Rkb3V0LnJlcGxhY2UoL1xcLyQvLCAnJykudHJpbSgpO1xuICBpZiAoIWRldmVsb3BlclJvb3QpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhhd2FpdCBnZW5lcmF0ZUVycm9yTWVzc2FnZShgJ3hjb2RlLXNlbGVjdCAtcCcgcmV0dXJuZWQgYW4gZW1wdHkgc3RyaW5nYCkpO1xuICB9XG4gIC8vIHhjb2RlLXNlbGVjdCBtaWdodCBhbHNvIHJldHVybiBhIHBhdGggdG8gY29tbWFuZCBsaW5lIHRvb2xzXG4gIGNvbnN0IHtDRkJ1bmRsZUlkZW50aWZpZXJ9ID0gYXdhaXQgcmVhZFhjb2RlUGxpc3QoZGV2ZWxvcGVyUm9vdCk7XG4gIGlmIChDRkJ1bmRsZUlkZW50aWZpZXIgPT09IFhDT0RFX0JVTkRMRV9JRCkge1xuICAgIHJldHVybiBkZXZlbG9wZXJSb290O1xuICB9XG5cbiAgbG9nLmVycm9yQW5kVGhyb3coYXdhaXQgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoYCcke2RldmVsb3BlclJvb3R9JyBpcyBub3QgYSB2YWxpZCBYY29kZSBwYXRoYCkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZnVsbCBwYXRoIHRvIFhjb2RlIERldmVsb3BlciBzdWJmb2xkZXIgdmlhIERFVkVMT1BFUl9ESVIgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBGdWxsIHBhdGggdG8gWGNvZGUgRGV2ZWxvcGVyIHN1YmZvbGRlclxuICogQHRocm93cyB7RXJyb3J9IElmIGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXRyaWV2ZSBhIHByb3BlciBwYXRoXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tRGV2ZWxvcGVyRGlyICgpIHtcbiAgY29uc3QgZGV2ZWxvcGVyUm9vdCA9IHByb2Nlc3MuZW52LkRFVkVMT1BFUl9ESVI7XG4gIGNvbnN0IHtDRkJ1bmRsZUlkZW50aWZpZXJ9ID0gYXdhaXQgcmVhZFhjb2RlUGxpc3QoZGV2ZWxvcGVyUm9vdCk7XG4gIGlmIChDRkJ1bmRsZUlkZW50aWZpZXIgPT09IFhDT0RFX0JVTkRMRV9JRCkge1xuICAgIHJldHVybiBkZXZlbG9wZXJSb290O1xuICB9XG5cbiAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSBwYXRoIHRvIFhjb2RlIERldmVsb3BlciBkaXIgJyR7ZGV2ZWxvcGVyUm9vdH0nIHByb3ZpZGVkIGluIERFVkVMT1BFUl9ESVIgYCArXG4gICAgYGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHZhbGlkIHBhdGhgKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGZ1bGwgcGF0aCB0byBYY29kZSBEZXZlbG9wZXIgc3ViZm9sZGVyLlxuICogSWYgREVWRUxPUEVSX0RJUiBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBwcm92aWRlZCB0aGVuIGl0cyB2YWx1ZSBoYXMgYSBwcmlvcml0eS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZW91dCBbMTUwMDBdIFRoZSBtYXhpbXVtIHRpbWVvdXQgZm9yIHhjb2RlLXNlbGVjdCBleGVjdXRpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byBYY29kZSBEZXZlbG9wZXIgc3ViZm9sZGVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJldHJpZXZpbmcgdGhlIHBhdGguXG4gKi9cbmNvbnN0IGdldFBhdGggPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0UGF0aCAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFVkVMT1BFUl9ESVIgPyBnZXRQYXRoRnJvbURldmVsb3BlckRpcigpIDogZ2V0UGF0aEZyb21YY29kZVNlbGVjdCh0aW1lb3V0KTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlcyBYY29kZSB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgWzE1MDAwXSBUaW1lb3V0IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0ZXJtaW5hbCBjb21tYW5kcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGltcG9ydChcInNlbXZlclwiKS5TZW1WZXIgfCBudWxsPn0gWGNvZGUgdmVyc2lvblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhIGZhaWx1cmUgd2hpbGUgcmV0cmlldmluZyB0aGUgdmVyc2lvblxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRWZXJzaW9uV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBkZXZlbG9wZXJQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcbiAgLy8gd2Ugd2FudCB0byByZWFkIHRoZSBDRkJ1bmRsZVNob3J0VmVyc2lvblN0cmluZyBmcm9tIFhjb2RlJ3MgcGxpc3QuXG4gIGNvbnN0IHtDRkJ1bmRsZVNob3J0VmVyc2lvblN0cmluZ30gPSBhd2FpdCByZWFkWGNvZGVQbGlzdChkZXZlbG9wZXJQYXRoKTtcbiAgcmV0dXJuIHNlbXZlci5jb2VyY2UoQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBYY29kZSB2ZXJzaW9uIG9yIHRoZSBjYWNoZWQgb25lIGlmIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIFsyXSBIb3cgbWFueSByZXRyaWVzIHRvIGFwcGx5IGZvciB2ZXJzaW9uIHJldHJpZXZhbFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgWzE1MDAwXSBUaW1lb3V0IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0ZXJtaW5hbCBjb21tYW5kc1xuICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KFwic2VtdmVyXCIpLlNlbVZlciB8IG51bGw+fSBYY29kZSB2ZXJzaW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGEgZmFpbHVyZSB3aGlsZSByZXRyaWV2aW5nIHRoZSB2ZXJzaW9uXG4gKi9cbmNvbnN0IGdldFZlcnNpb25NZW1vaXplZCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gZ2V0VmVyc2lvbk1lbW9pemVkIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWGNvZGVWZXJzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvblN0cmluZyBYY29kZSB2ZXJzaW9uIGFzIGEgc3RyaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbkZsb2F0IFhjb2RlIHZlcnNpb24gYXMgYSBmbG9hdCBudW1iZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYWpvciBNYWpvciBudW1iZXIgb2YgWGNvZGUgdmVyc2lvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbm9yIE1pbm9yIG51bWJlciBvZiBYY29kZSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge251bWJlcj99IHBhdGNoIFBhdGNoIG51bWJlciBvZiBYY29kZSB2ZXJzaW9uIChpZiBleGlzdHMpXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZXMgWGNvZGUgdmVyc2lvblxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2UgW2ZhbHNlXSBXaGV0aGVyIHRvIHBhcnNlIHRoZSB2ZXJzaW9uIHRvIGEgWGNvZGVWZXJzaW9uIHZlcnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIFsyXSBIb3cgbWFueSByZXRyaWVzIHRvIGFwcGx5IGZvciBnZXR0aW5nIHRoZSB2ZXJzaW9uIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgWzE1MDAwXSBUaW1lb3V0IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0ZXJtaW5hbCBjb21tYW5kc1xuICogQHJldHVybnMge1Byb21pc2U8WGNvZGVWZXJzaW9uIHwgc3RyaW5nPn0gWGNvZGUgdmVyc2lvbiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGBwYXJzZWAgZmxhZ1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhIGZhaWx1cmUgd2hpbGUgcmV0cmlldmluZyB0aGUgdmVyc2lvblxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRWZXJzaW9uIChwYXJzZSA9IGZhbHNlLCByZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb25NZW1vaXplZChyZXRyaWVzLCB0aW1lb3V0KTtcbiAgLy8geGNvZGUgdmVyc2lvbiBzdHJpbmdzIGFyZSBub3QgZXhhY3RseSBzZW12ZXIgc3RyaW5nOiBwYXRjaCB2ZXJzaW9ucyBvZiAwXG4gIC8vIGFyZSByZW1vdmVkIChlLmcuLCAnMTAuMC4wJyA9PiAnMTAuMCcpXG4gIGNvbnN0IHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uLnBhdGNoID4gMCA/IHZlcnNpb24udmVyc2lvbiA6IGAke3ZlcnNpb24ubWFqb3J9LiR7dmVyc2lvbi5taW5vcn1gO1xuICBpZiAoIXBhcnNlKSB7XG4gICAgcmV0dXJuIHZlcnNpb25TdHJpbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnNpb25TdHJpbmcsXG4gICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KHZlcnNpb25TdHJpbmcpLFxuICAgIG1ham9yOiB2ZXJzaW9uLm1ham9yLFxuICAgIG1pbm9yOiB2ZXJzaW9uLm1pbm9yLFxuICAgIHBhdGNoOiB2ZXJzaW9uLnBhdGNoID4gMCA/IHZlcnNpb24ucGF0Y2ggOiB1bmRlZmluZWQsXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHZlcnNpb25TdHJpbmc7XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBodHRwczovL3RyYWMubWFjcG9ydHMub3JnL3dpa2kvWGNvZGVWZXJzaW9uSW5mb1xuICogdG8gc2VlIHRoZSBhY3R1YWwgbWFwcGluZyBiZXR3ZWVuIGNsYW5nIGFuZCBvdGhlciBjb21wb25lbnRzLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz8+fSBUaGUgYWN0dWFsIENsYW5nIHZlcnNpb24gaW4geC54LngueCBvciB4LngueCBmb3JtYXQsXG4gKiB3aGljaCBpcyBzdXBwbGllZCB3aXRoIENvbW1hbmQgTGluZSBUb29scy4gYG51bGxgIGlzIHJldHVybmVkXG4gKiBpZiBDTFQgYXJlIG5vdCBpbnN0YWxsZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENsYW5nVmVyc2lvbiAoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud2hpY2goJ2NsYW5nJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuaW5mbygnQ2Fubm90IGZpbmQgY2xhbmcgZXhlY3V0YWJsZSBvbiB0aGUgbG9jYWwgc3lzdGVtLiAnICtcbiAgICAgICdBcmUgWGNvZGUgQ29tbWFuZCBMaW5lIFRvb2xzIGluc3RhbGxlZD8nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ2NsYW5nJywgWyctLXZlcnNpb24nXSk7XG4gIGNvbnN0IG1hdGNoID0gL2NsYW5nLShbMC05Ll0rKS8uZXhlYyhzdGRvdXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgbG9nLmluZm8oYENhbm5vdCBwYXJzZSBjbGFuZyB2ZXJzaW9uIGZyb20gJHtzdGRvdXR9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG1hdGNoWzFdO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2ZXJzaW9uIG9mIGlPUyBTREsgc3VwcG9ydGVkIGJ5IHRoZSBpbnN0YWxsZWQgWGNvZGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBbMTUwMDBdIFRpbWVvdXQgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRlcm1pbmFsIGNvbW1hbmRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgU0RLIHZlcnNpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgU0RLIHZlcnNpb24gbnVtYmVyIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnaXBob25lc2ltdWxhdG9yJywgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcbiAgY29uc3Qgc2RrVmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG4gIGNvbnN0IG1hdGNoID0gL1xcZC5cXGQvLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyBpT1MgU0RLIHZlcnNpb246ICcke3Nka1ZlcnNpb259J2ApO1xuICB9XG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2ZXJzaW9uIG9mIGlPUyBTREsgc3VwcG9ydGVkIGJ5IHRoZSBpbnN0YWxsZWQgWGNvZGVcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBbMTUwMDBdIFRpbWVvdXQgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRlcm1pbmFsIGNvbW1hbmRzXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbMl0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBTREsgdmVyc2lvblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBTREsgdmVyc2lvbiBudW1iZXIgY2Fubm90IGJlIGRldGVybWluZWRcbiAqL1xuY29uc3QgZ2V0TWF4SU9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiBnZXRNYXhJT1NTREsgKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnksIHRpbWVvdXQpO1xuICB9XG4pO1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2ZXJzaW9uIG9mIHR2T1MgU0RLIHN1cHBvcnRlZCBieSB0aGUgaW5zdGFsbGVkIFhjb2RlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgWzE1MDAwXSBUaW1lb3V0IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0ZXJtaW5hbCBjb21tYW5kc1xuICogQHJldHVybnMge3N0cmluZ30gVGhlIFNESyB2ZXJzaW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFNESyB2ZXJzaW9uIG51bWJlciBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBhcmdzID0gWyctLXNkaycsICdhcHBsZXR2c2ltdWxhdG9yJywgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcbiAgY29uc3Qgc2RrVmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG4gIGlmIChpc05hTihwYXJzZUZsb2F0KHNka1ZlcnNpb24pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyB0dk9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuICByZXR1cm4gc2RrVmVyc2lvbjtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmVyc2lvbiBvZiB0dk9TIFNESyBzdXBwb3J0ZWQgYnkgdGhlIGluc3RhbGxlZCBYY29kZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFsxNTAwMF0gVGltZW91dCBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGVybWluYWwgY29tbWFuZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIFsyXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllc1xuICogQHJldHVybnMge3N0cmluZ30gVGhlIFNESyB2ZXJzaW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFNESyB2ZXJzaW9uIG51bWJlciBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxuICovXG5jb25zdCBnZXRNYXhUVk9TU0RLID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiBnZXRNYXhUVk9TU0RLIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmV4cG9ydCB7XG4gIGdldFBhdGgsIGdldFZlcnNpb24sIGdldE1heElPU1NESywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LFxuICBnZXRNYXhUVk9TU0RLLCBnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5LCBnZXRDbGFuZ1ZlcnNpb24sXG4gIGdldFBhdGhGcm9tRGV2ZWxvcGVyRGlyLCBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0LFxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsTUFBTUEseUJBQXlCLEdBQUcsQ0FBQztBQUNuQyxNQUFNQyxlQUFlLEdBQUcsb0JBQW9CO0FBRTVDLE1BQU1DLEdBQUcsR0FBR0MsZUFBTSxDQUFDQyxTQUFTLENBQUMsT0FBTyxDQUFDO0FBU3JDLGVBQWVDLHNCQUFzQixDQUFFQyxPQUFPLEdBQUdDLHNCQUFhLEVBQUU7RUFDOUQsTUFBTUMsb0JBQW9CLEdBQUcsTUFBT0MsTUFBTSxJQUFLO0lBQzdDLE1BQU1DLFVBQVUsR0FBRyxNQUFNLElBQUFDLHFCQUFZLEVB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